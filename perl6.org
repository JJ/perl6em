#+TITLE:  Perl 6, the musical


#+latex_compiler: xelatex
#+LaTeX_CLASS: book
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \setmonofont{DejaVu Sans Mono}

* â„µ - Principles
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

A few principles that inspire this (book|booklet|manual|you name it),
originally conceived to help non-programmers get into Perl 6

*** Learning should be fun and engaging: learn by doing.
*** You are the master of your learning process, and tools, and outcome. 
*** Learning never stops.
*** Learning is a two-way process. There is no professor, no student: learning happens ideally in a community. 

* Î± - Motivation
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

*** Teaching programming to (almost) non-programmers.
*** Contemplate the possibilities of Perl 6 as a beginner's language.
*** Show the beauty and craft of programming.
*** Use project-based learning throughout and flipped-learning techniques.

* 0 - Design thinking
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

Source https://dschool.stanford.edu/sandbox/groups/designresources/wiki/36873/attachments/74b3d/ModeGuideBOOTCAMP2010L.pdf?sessionID=e62aa8294d323f1b1540d3ee21e961cf7d1bce38

** Empathization

Find users, find out about them, care about them, know their stories. Maybe you are the user, maybe it's someone close to you.

** Definition

Define the challenge, what you want to do, express the problem. This
phase can be merged with the next one, since it is difficult to define
the problem without recourse about how you are going to solve the
problem itself. 

** Ideate

Try to find out the solution to the problems your users have. 


In this phase you are supposed to produce ideas to solve the
problem. There will be no restriction other than whatever is required
by your target. You might want to create problems that imply certain
devices and not others, or solutions that cost no more than a certain
amount of money. 

** Prototype

We will transition to actually doing something, incrementally. And
this is a phase, together with the following one, that is actually in
the engineering realm, so we are in familiar ground here. 

** Test

If you are the user yourself, try it out. See if it is useful as
intended. Actually, test-driven design dictates that you cannot
actually prototype without testing in advance. So testing and
prototyping go hand in hand. 


* The tools of the trade 

This part will not be leading away from the design thinking mindset,
but actually will be getting into the last phases of it. Whatever idea
you had in mind will have to be kept stashed to go back to it whenever
you need it. In fact, we are entering the phase called /prototyping/,
or seen in another way, you are trying to solve a problem for a target
audience, yourself, by choosing the right tools. 

In this phase you will find that there's no perfect tool for doing
everything.

#+BEGIN_QUOTE
Although the combination Linux + Emacs comes pretty close 
#+END_QUOTE

Let's start with the operating system. That would be Linux. Whew, that
was short. But let's proceed to that thing that actually allows users to run programs, the shell. 

** Shells 

Then, the command line interpreter, also called /shell/. This might seem like a given, but
in fact different command line interpreters have different
capabilities. In fact, even the [[https://www.gnu.org/software/bash/][humble bash]] has
interesting capabilities you can use. Main thing you want to tap is
the possibility of displaying interesting information in the command
line, such as the directory you are working on or, later on, the
branch of the repository you are in. And, in that sense, 
there are quite a few choices here, but the main
thing about them is the possibility of /theming/ them, that is, making
a configuration that allows, mostly, find the information we mention
above by just selecting a /theme/. In that sense [[http://zsh.sourceforge.net/][zsh]] and [[https://fishshell.com/][fish]] are very
strong contenders. Install them the usual way, and then select a theme
that goes easily with your programming habits;
[[https://github.com/robbyrussell/oh-my-zsh][Oh My Zsh]] or [[https://github.com/Bash-it/bash-it][bash-it]] are good places to start. 

Play a bit with the themes or options until you find one with all the
colors and contrast you want. And then come back here for the...

** Editors. 

The choice of an editor goes beyond mere utility to become an
indentity, a side to stand when the flame war starts. As above, the
motto is always /suit yourself/, but since we are in the realm of
Perl6, I would propose [[http://atom.io][Atom]] as the editor to use. It is a modern
editor, it has got a good and evolving support for Perl 6, and it is
free software.

Not that the traditional Emacs and Vi/Vim are not good choices too. At
least Emacs, but Atom is easier to use and is improving in speed and
support by the minute. Besides, it has got everything it takes for
professional editor: syntax highlighting, being able to do some checks
from the editor itself, and allow running and debugging. It has got
all that, so that will be it. 

To go with the editor, you need some relatively fast way of inputting
some characters such as áˆ or Ð©. I have used the application "Character
Map" that comes with Ubuntu; after finding a character by the name of
the alphabet, you can go to Character Details and copy/paste it to
wherever you want it used. You can also click twice and the character
will appear in the "Text to copy" slot. 

[[./img/charmap.png]]

Of course, something would be missing here if I did not mention `vim`. Here you go, a mention.

** Shells within editors

Editors are cool because they allow to work with all kind of symbols
that are not exactly text, or that  cannot be produced with a
combination of key strokes. Emacs is great at that, and it can access
the whole set of symbols that are out there by name using a
combination of keys. And it can also run a shell inside, your favorite
shell, in fact. So enter =emacs= and then type =Escape key + x= and
then, when a prompt appears in the lower line, =shell= and you will
have your shell running /inside/ Emacs, with access to all kind of
goodies, like saving sessions as files, searching using all Emacs
facilities, and all kind of symbols that can be used in it. 

* ÃŸ - We need to talk about Unicode
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

This does not belong to the language proper, but it is still something
that has to be mentioned. Languages are used to write applications,
and these can use any language in the world. [[https://unicode-table.com/es/][Unicode]] is the way to use
any alphabet, and some [[http://www.omniglot.com/conscripts/natlangs.htm][neographies]] and emoticons, in our
programs. Luckily enough, Perl6 packs one of the best supports for
this; unluckily, Unicode is complicated /per se/, so we will have to
learn a bit of linguistics to understand how we, later on, are going
to handle this, which we will even if we write only for ourselves.

First important concept is the /codepoint/. A code point is pretty
much equivalent to a letter, although it can be a symbol or also a
formatting instruction such as Tab or Newline. Every code point
corresponds to a numeric combination, which is usually expressed in
hexadecimal; for instance, =0x2017= corresponds to the character =â€—=,
part of a table-drawing set. Every character also has a series of
attributes, including the category; this character belongs to the =Po=
[[https://en.wikipedia.org/wiki/Unicode_character_property#General_Category][category]],
meaning that it is /Punctuation, other/. The [[http://userguide.icu-project.org/strings/properties][properties]] include a
series of attributes such as the fact that they are numeric or can do
things like folding to a particular case or be joined to the next
character, or even if the direction they are written in. 

Characters are written as [[http://mathias.gaunard.com/unicode/doc/html/unicode/introduction_to_unicode.html#unicode.introduction_to_unicode.grapheme_clusters][graphemes]], and usually a code point
corresponds to a single written grapheme; however, in some cases code
points group to form a /grapheme cluster/, which is a set of code
points that constitute a grapheme; the most common example is letters
with marks such as Ã¡, but more complicated expressions might be
thought of. Or not, depending on your imagination. 

You write graphemes and grapheme clusters as /glyphs/, or letters. And
these are typeset, in a particular environment, using /fonts/. A font
is a set of mathematical formulae, yes, there is math involved, that
allows to render a particular letter in many different sizes and forms
such as italics or boldface. The fact that they are a formula, and
that you have to design formulae for every single glyph, means that
not all glyphs might be available in all fonts. Some fonts will have
all, or most of them, some of them not. And that, in turn, means that
some Etruscan letter such as this one ðŒš that renders beautifully in
your editor might show up as an x-marked rectanble or question mark
somewhere else, a console or a word processor. In fact, depending on
how you are reading this, you might not see the glyph I'm referring to
at all. 

Your take away message here is that you need to know how to use
Unicode in whatever program you use, and that some particular
structures of the program, like operators or names, will use graphemes
with particular properties, probably something alphabetic-like. Also
that unicode is complicated, but that you should better learn about it
as soon as possible, as in now. 
* The expressions

The first thing you need to know about a language, any language, is
how to compute things. Compute in the more general sense: combine
things to give other things. This, in general, is called expression,
which, also in general, is a bunch of symbols linked by *operators*. 

Generally, modern computer languages are able to work with many
different kind of symbols, and Perl6 is no exception. Let's start with
that.

** REPLs and how to use them as glorified calculators

A
[[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]]
is a Read-Eval-Print loop. it is a program included with most
interpreted languages, that presents a command-line prompt and into
which you can type expressions, and, later on, full statements. But,
for the time being, let's type


#+BEGIN_EXAMPLE bash
perl6
#+END_EXAMPLE

And we will be into a perl6 REPL into which you can type Perl6 stuff.

Let's try the simplest thing:


#+BEGIN_EXAMPLE perl6
To exit type 'exit' or '^D'
> sin(Ï€/2)
#+END_EXAMPLE

You will have to find a way to type that Ï€, by copy/pasting it from
some website or google or right this. It will return the sine of Ï€/2,
which, as you know, is 1. 

And this is cool, because only some languages are able to handle this
kind of expressions, and, even more, to use it correctly in math. But
you can do even more:


#+BEGIN_EXAMPLE perl6
sin(Ï€/2) +1
#+END_EXAMPLE

You can do that by copying/pasting, or else install =Linenoise=, a
command line that allows you to go back to previous command by typing
arrow-up. Do it with


#+BEGIN_EXAMPLE bash
zef install Linenoise
#+END_EXAMPLE

You can use the usual arithmetic operators =+,-,*,/= but Perl6 adds
two typographic operators, Ã· and Ã— (these ones are produced in the
Spanish keyboard with May+AltGr+ comma or period), like


#+BEGIN_EXAMPLE perl6
sin(Ï€/3) Ã— sin(Ï€/3) + cos(Ï€/3) Ã— cos(Ï€/3)
#+END_EXAMPLE

Or, even better


#+BEGIN_EXAMPLE perl6
sin(Ï€/3)Â² + cos(Ï€/3)Â²
#+END_EXAMPLE

One of the objectives of Perl6 is to use the whole range of characters
that Unicode, if not modern keyboards, offer. This simplifies
expressions and makes them more readable. 

** Now that we mention Unicode

Unicode is the way to express all alphabets in the world, and then
some things that are not really alphabets. It uses up to around sixty
thousand symbols, and allows us to write, using modern operating
systems, editors and languages, anything that would have to be
expressed in living or dead languages, and even some
emoticons. Unicode is evolving constantly, and for the people means
that they will be able to use characters that are usual in their own
language, and also some usual in mathematical expressions. 

Since not all languages, editors, operating systems or even keyboards
are *modern* in that sense, some impedance should be expected. But
Perl 6 will not get in your way, allowing you to use them just they
way they should, so if you want to raise something to the second power
you will not have to, although you can, write x**2 but simply xÂ².

** It's not only numbers

All the expressions written above are numbers. 


#+BEGIN_EXAMPLE perl6
(sin(Ï€/3)Â² + cos(Ï€/3)Â²).WHAT
#+END_EXAMPLE

is going to return =(Num)=, indicating that it is simply a Number,
actually a real number. This =.WHAT=, together with surrounding the
expression via parentheses meaning grouping, is a way to apply a
/property/ or to call a /method/ on that object. In Perl6, everythin
is an object, and objects have a class, and you want to call methods
that correspond to objects of that class, append a dot and use the
method, possibly with some arguments like =WHAT(is, "the",
$what)=. Let's not worry about that for the time being, or about
classes themselves. Just with the fact that every expression is an
object, and those objects belong to a class; every class in Perl6
/descends/ from the ur-class called Î¼ or =Mu=. And among the
[[https://docs.perl6.org/type/Mu][properties of Mu]] is that you can call this =WHAT=. Any other class
descends from this one, so /you can call =.WHAT= on any object of any
class/. That is the take-home message, even if you might not know, so
far, what is an object, or a class. Second take home message:
/different objects also have different classes/. 

Since both /objects/ at the sides of the =+= are Nums, you
can add or substract them or do any other arithmetic operation, but you cannot do 


#+BEGIN_EXAMPLE perl6
sin(Ï€/3)Â² + cos(Ï€/3)Â² + " is 1"
#+END_EXAMPLE

will yield this error
#+CAPTION: Errorred expression in the REPL
#+NAME:   fig:chap2-expression
[[./img/expression-error.png]]

And the reason for that can be found out by typing:
#+BEGIN_EXAMPLE perl6
" is 1".WHAT
#+END_EXAMPLE

Which, whatever it is, is not a =Num=, so it cannot be added. 
That shows that there are more types of data you can use and work with
from the REPL. In fact, there are a lot. In general, you cannot mix
and match and, also in general, every one has got its own operators
you can work with. You can mix fractions with integer numbers, for
instance: 

#+BEGIN_EXAMPLE perl6
 â…“+4/3
#+END_EXAMPLE

And 

#+BEGIN_EXAMPLE perl6
(â…“+4/3).WHAT
#+END_EXAMPLE

will return =(Rat)=, a Rational, same as =â…“+4=. In fact, most
[[http://blogs.perl.org/users/ovid/2015/02/a-little-thing-to-love-about-perl-6-and-cobol.html][floating point numbers in Perl 6 will be represented as rational]],
unless we explicitly tell the interpreter to deal with them as
floating point, that is real, numbers, which, BTW, cannot be something
else that fractional numbers since they use a finite representation in
computers. Mostly.

However, in some cases you can try and mix different things using an
operator. Operator "~" concatenates stuff, that is, joins things that
look like words and letters, for instance

#+BEGIN_EXAMPLE perl6
6 ~ "6"
#+END_EXAMPLE

will return =66=, and anything you put there will be concatenated. =~=
is an operator that is not picky about what it has got in both ends. 

You cannot add strings together, because that is what they are, but curiously enough, you can multiply them:

#+BEGIN_EXAMPLE perl6
"1" ~ "\n" ~ "2" x 2 ~ "\n" ~ "3" x 3 ~ "\n" ~ "2" x 2 ~ "\n" ~ "1"
#+END_EXAMPLE

This being a rather nice and utterly useless example on the operator
=x=, which /multiplies/ or rather /replicates/ whatever character of
string it is related to. Introduced together with =\n", the carriage
return, so that if forms a nice pile of stuff. 

Which is shorter and better in this example

#+BEGIN_EXAMPLE perl6
for <1 2 3 2 1>  { say $_ x $_ }
#+END_EXAMPLE

but that's something we will see later on, when we talk about loops
and all that's nice and beautiful about it. 

** And there's more

Numbers and words are simple things. But you can string them together
in something more complex. You can have sets of them, or lists of
them, or combine them as sets of lists of sets of whatever. Perl 6 is
great because you do not need to make all things in a complex
structure be of the same type. You can create a list with the less than
and more than sign, this way:

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²>
#+END_EXAMPLE

And with lists, you can do things like sorting:

#+BEGIN_EXAMPLE perl6
sort <a b 7 â…“ Ï€Â²>
#+END_EXAMPLE

or combine lists to create a new one using the =X= operator, called
*cross product* 

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²> X < â†’ â† >
#+END_EXAMPLE

for long lists, you might want to use only the first and last term 

#+BEGIN_EXAMPLE perl6
1...222
#+END_EXAMPLE

via the *yada, yada, yada* operator, or, even better,

#+BEGIN_EXAMPLE perl6
1 â€¦ 333
#+END_EXAMPLE

Not so easy or straightforward to combine lists. However, it is [[http://stackoverflow.com/questions/34567902/perl-6-list-concatenation-without-slip][not
impossible]] actually:

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²> , < â†’ â† >
#+END_EXAMPLE

is going to create a new list with two elements, each one of which is
a list. You can *flatten* it:

#+BEGIN_EXAMPLE perl6
flat <a b 7 â…“ Ï€Â²> , < â†’ â† >
#+END_EXAMPLE

But the coolest thing with lists is the stuff you can do to all of
them at the same time:

#+BEGIN_EXAMPLE perl6
[+] 1 â€¦ 333
#+END_EXAMPLE

will add everything together. Any operator you put inside brackets
will be applied to all in turn. Try =[*] 1 â€¦ 333=, for instance.

But the coolness factor can be increased:
#+BEGIN_EXAMPLE perl6
[+] 1,3 â€¦ 333
#+END_EXAMPLE

and even
#+BEGIN_EXAMPLE perl6
[+] 1,3,9 â€¦ 333
#+END_EXAMPLE

Perl6 is able to deal with arithmetic and geometric progressions out
of the box. And even infinite ones:

#+BEGIN_EXAMPLE perl6
1,3,9 â€¦ âˆž
#+END_EXAMPLE

You can obtain the 100th term using

#+BEGIN_EXAMPLE perl6
(1,3,9 â€¦ âˆž)[100]
#+END_EXAMPLE

or, why not, the terms from 1000 to 1100

#+BEGIN_EXAMPLE perl6
(1,3,9 â€¦ âˆž)[1000â€¦1100]
#+END_EXAMPLE

which will return a pile of numbers, separated by spaces. Besides, at the same time, we have seen how to deal with a single term in a
list, and how to work with a series of terms. 

* Î³ - Thinking like computers do
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You probably know that computers are unlike humans. But since
expressions are entered in pretty much the same way you would use
somewhere else, it's no big deal. However, once you want to
deconstruct what actually needs to be done to make a computer do
whatever you want it to do, you have to start to think like a
computer, in what is known as computational thinking. It is kind of a
game of "Simon says". You have to precede every instruction you give a
computer by something that indicates you want it to do precisely that,
and then you have to say very precisely what it needs to do.

But there is more to that, the fact that you also need to indicate the
/sequence/ of actions you want the computer to do by indicating that
in your program. When you work with the REPL, as we have done above,
the sequence is quite clear: you say something, press Enter, the
computer thinks for a while or what looks like nothing, you have the
response. However, when the program gets a bit more complicated, you
also have to think, in a particular point in time, where the computer
might be and what that implies regarding values or results you need to
proceed. 

Which is why we talk about
[[https://en.wikipedia.org/wiki/Computational_thinking][computational thinking]] as a series of techniques for solving problems
using computers, including all the steps you need to take to identify
the problem, put it in a way that can be understood and processed by a
computer, and then express every step as instructions in program that
will, eventually, solve the problem. 

We will get back to this later on, but for the time being there are a
couple of techniques you will need to understand. First is /pattern
recognition/, which means finding what several different pieces of
information have in common and, in turn, what to do to solve a problem
in a case given that you know how to solve it in another case which
follows the same pattern. When you find something that has a regular
increasing or arithmetic pattern, for instance, you will discover that
you can use lists or sequences to solve it, and apply whatever you
know already on how to deal with sequences. 

The second technique we should focus on right now is /problem
decomposition/, how to break down a problem in different parts that
can, more easily, solved. For instance, you want to find what would be
the number a sequence will reach if left to grow until infinity; first
you will have to solve the problem of representing the sequence, which
might not be inmediate, and then how to apply known techniques of
limit finding, such as
[[http://tutorial.math.lamar.edu/Classes/CalcI/LimitsProperties.aspx#Limit_Props][finding the function that represents the sequence]] and then applying
what is known about function limits to that sequence. 

Every part of a problem will eventually become an instruction or
group of instructions called usually /subroutines/ or /functions/. But
for the time being, it is enough to know that breaking down a problem
in parts you already know how to solve is the key for solving problems
of any size. 

* Î´ - Working as a team
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You will never walk alone when solving a problem. Even if you are
working in a side project, something you thought about yourself, you
will need an easy way to keep track of changes and also to easily
incorporate whatever suggestions or even changes somebody else might
be doing to your code.


* Îµ - Web weaving
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
  
Whatever you do nowadays in computing, you will have to end up
presenting something somewhere, and that somewhere will most probably
be the web nowadays. So it does not harm, and it will benefit greatly,
to learn from now what the web is all about and how we can extract
information from it, use it to interact with people and publish our
data so that anyone in the whole wide world can see it. 


* Î¶ - Pack all your troubles in a container
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  
Applications run nowadays in all kind of places, so eventually someone
found a way to put all the stuff you need to run them in a single
tupperware container and ship it anywhere you need them, in the same
way as you pack your potato omelette in a tupper and carry it to grab
a byte in a picnic or during your train trip to Poughkeepsie, as you
are wont to do. Same goes for programs. Create it, pack it, take it
anywhere: the cloud, your other computer, anywhere you please. And if
you add another tupper with mandarines and yet another with a few
cupcakes, you have got your whole snack-a-lot ready to take anywhere.

Applications nowadays are composed of the equivalent of a three or
even more course meal. They have several courses plus snacks and even
a doggie bag to pack leftovers and a plastic bag for organic
trash. You can carry them in several places on you and your clothes,
but it is much better to just pack containers for everything and lay
them out on the table when you are ready to eat. In the case of
applications, they can be data processing units, data storing units,
data fooing and data baring units. Does not really matter what they
are, but the thing it that /containerization/ makes easy the creation
of a whole suite that can be stored and shipped anywhere. 

* Î· - Testing for the win
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
  
/If it is not tested, it is broken/ is something that you should learn
as soon as you start to crank out code. It actually means /If it is
not *automatically* tested, it is broken/, that is, it is not enough
that you give it two or maybe one input, and declare yourself
satisfied with it. No, son, that is not testing and you know it. 
