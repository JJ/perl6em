#+TITLE:  Perl 6, the musical


#+latex_compiler: xelatex
#+LaTeX_CLASS: book
#+HTML_MATHJAX:  path:"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \setmonofont{DejaVu Sans Mono}

* Introduction
This book is about learning programming using a promising, and almost
completely new, language: Perl 6. But it is only Perl 6 specific in
a minority of the content. Most chapters that deal with Perl 6 could
be rewritten using any other language, preferably a new, cool language
such as Go or Rust. I, or someone, might do it some day. But for the
time being, let us be content with Perl 6. Which is also new and cool.

* â„µ - Principles
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

A few principles that inspire this (book|booklet|manual|you name it),
originally conceived to help non-programmers get into Perl 6

** Learning should be fun and engaging: learn by doing.

The best way to make people actually learn something is by putting
immediately to practice whatever is being learned, be it programming
or weaving. So you should have your computer handy and learn the tools
as soon as possible to put things to practice. 

** You are the master of your learning process, and tools, and outcome. 
You should learn at your own step, stopping whenever you want and
actually taking lessons when you feel like doing it. Engagement will
ensue. 

** Learning never stops.

If you learn only during the short period where /class/ is taking
place, you will not learn too much. You have to digest and assimilate
and come up with new ideas. Some of them will be relevant to whatever
you are learning, some of them will be revealed as relevant later on,
some of them will be simply discarded. But you can leverage whatever
experience you have to enhance what you are learning, even more so if
it is a programming language. 

** Learning is a two-way process. There is no professor, no student: learning happens ideally in a community. 

This is kinda /zen/, but then the whole thing stinks of a holistic
experience, where you learn about life by learning about programming
and back. That also means that learning comes from every direction at
once: the other students, maybe whoever is preparing objectives and
material for the day, but that person will also learn new things about
him or herself and about whatever is teaching, because the best way to
learn is to prepare something to be taught to others. 

Besides, there is no learning outside self-learning. But maybe that is
a completely different story. 

* Ð± - Motivation
   :PROPERTIES:
   :UNNUMBERED: T
   :END:

This is (mostly) a book on Perl 6. But my initial intention was not to
show how to program in Perl 6. Here are a few of my motivations, which
might be also your own for actually reading and following this book. 

** Teaching programming to (almost) non-programmers.

Most programming books seem to be written either for people that already know
how to program or for people that barely knows how to press
keys. There must be a middle ground, and I try to tread it with this
book. If know how to use a computer, you should be ready to go the
whole nine yards and learn to create things in Perl 6 by the end of
the book, if that eventually happens. 

** Contemplate the possibilities of Perl 6 as a beginner's language.
There seems to be a consensus that there is such a thing as a /good
language for beginners/, and that that language is Python. Well, maybe
it is, but why would any other languages, Rust, JavaScript or even C++
be worse? Asking about the best programming language for beginners is
like asking about the best foreign language for beginners. Evidently,
the best is the language you want to learn. If you want to learn
Chinese, you do not learn first... whatever language is closer to
yours and easier than Chinese (maybe Vietnamese? No idea, really, I
got trapped in the metaphor). You learn Chinese and are done with it. 

Point is, when you want to learn to program you usually have some kind
of job or task in mind. The best language to learn programming is a
language that can do that job. And Perl 6 can be that language.

** Show the beauty and craft of programming.

"Good technically, but lacks passion" is probably one of the worst
things that can be said about a musician or even a footballer. Should
be the case also for programmers. Those focused on getting the job
done well /technically/ will probably lack the will, or the stamina,
to learn new things or to completely switch the language or the
toolbelt you are using. Along with programming, you have to make
students learn the craft and also the beauty of a minimalist, fast
and beautiful program. 

** Use project-based learning throughout and flipped-learning techniques.


Which boils down to "talk little, do a lot". No slides, no heavyweight
course materials, just a screen with examples, and make people perform
short tasks and reproduce what is being said by themselves. Hands have
better memory than eyes. Use that. 

In this book, in most cases activities will have a particular purpose
and will follow or flow from one chapter, or asides, to the next
ones, so that you will end up building one, or several, scripts
or programs or even notes that will be useful by themselves. 

* Î± - Design thinking
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

This has been mostly obtained from
[[https://dschool.stanford.edu/sandbox/groups/designresources/wiki/36873/attachments/74b3d/ModeGuideBOOTCAMP2010L.pdf?sessionID=e62aa8294d323f1b1540d3ee21e961cf7d1bce38][this document]] at Stanford University. /Design thinking/ teaches you
how to think like a designer, which means thinking in a way that
allows you to create something that is satisfying for yourself and
that fills the need of a customer. In the free software realm,
oftentimes /you/ are customer, so you will be satisfied twice for the
same low price. Anyway, there are several phases in thinking like a
designer. They are usually these ones. 

** Empathizing

Find users, find out about them, care about them, know their stories. Maybe you are the user, maybe it's someone close to you.

** Definition

Define the challenge, what you want to do, express the problem. This
phase can be merged with the next one, since it is difficult to define
the problem without recourse about how you are going to solve the
problem itself. 

** Ideate

Try to find out the solution to the problems your users have. 


In this phase you are supposed to produce ideas to solve the
problem. There will be no restriction other than whatever is required
by your target. You might want to create problems that imply certain
devices and not others, or solutions that cost no more than a certain
amount of money. 

** Prototype

We will transition to actually doing something, incrementally. And
this is a phase, together with the following one, that is actually in
the engineering realm, so we are in familiar ground here. 

** Test

If you are the user yourself, try it out. See if it is useful as
intended. Actually, test-driven design dictates that you cannot
actually prototype without testing in advance. So testing and
prototyping go hand in hand. 

* The tools of the trade 

This part will not be leading away from the design thinking mindset,
but actually will be getting into the last phases of it. Whatever idea
you had in mind will have to be kept stashed to go back to it whenever
you need it. In fact, we are entering the phase called /prototyping/,
or seen in another way, you are trying to solve a problem for a target
audience, yourself, by choosing the right tools. 

In this phase you will find that there's no perfect tool for doing
everything.

#+BEGIN_QUOTE
Although the combination Linux + Emacs comes pretty close 
#+END_QUOTE

Let's start with the operating system. That would be Linux. Whew, that
was short. But let's proceed to that thing that actually allows users to run programs, the shell. 

** Shells 

Then, the command line interpreter, also called /shell/. This might seem like a given, but
in fact different command line interpreters have different
capabilities. In fact, even the [[https://www.gnu.org/software/bash/][humble bash]] has
interesting capabilities you can use. Main thing you want to tap is
the possibility of displaying interesting information in the command
line, such as the directory you are working on or, later on, the
branch of the repository you are in. And, in that sense, 
there are quite a few choices here, but the main
thing about them is the possibility of /theming/ them, that is, making
a configuration that allows, mostly, find the information we mention
above by just selecting a /theme/. In that sense [[http://zsh.sourceforge.net/][zsh]] and [[https://fishshell.com/][fish]] are very
strong contenders. Install them the usual way, and then select a theme
that goes easily with your programming habits;
[[https://github.com/robbyrussell/oh-my-zsh][Oh My Zsh]] or [[https://github.com/Bash-it/bash-it][bash-it]] are good places to start. 

Play a bit with the themes or options until you find one with all the
colors and contrast you want. And then come back here for the...

** Editors. 

The choice of an editor goes beyond mere utility to become an
identity, a side to stand when the flame war starts. As above, the
motto is always /suit yourself/, but since we are in the realm of
Perl6, I would propose [[http://atom.io][Atom]] as the editor to use. It is a modern
editor, it has got a good and evolving support for Perl 6, and it is
free software.

Not that the traditional Emacs and Vi/Vim are not good choices too. At
least Emacs, but Atom is easier to use and is improving in speed and
support by the minute. Besides, it has got everything it takes for
professional editor: syntax highlighting, being able to do some checks
from the editor itself, and allow running and debugging. It has got
all that, so that will be it. 

To go with the editor, you need some relatively fast way of inputting
some characters such as áˆ or Ð©. I have used the application "Character
Map" that comes with Ubuntu; after finding a character by the name of
the alphabet, you can go to Character Details and copy/paste it to
wherever you want it used. You can also click twice and the character
will appear in the "Text to copy" slot. 

[[./img/charmap.png]]

Of course, something would be missing here if I did not mention `vim`. Here you go, a mention.

** Shells within editors

Editors are cool because they allow to work with all kind of symbols
that are not exactly text, or that  cannot be produced with a
combination of key strokes. Emacs is great at that, and it can access
the whole set of symbols that are out there by name using a
combination of keys. And it can also run a shell inside, your favorite
shell, in fact. So enter =emacs= and then type =Escape key + x= and
then, when a prompt appears in the lower line, =shell= and you will
have your shell running /inside/ Emacs, with access to all kind of
goodies, like saving sessions as files, searching using all Emacs
facilities, and all kind of symbols that can be used in it. 

* ÃŸ - We need to talk about Unicode
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

This does not belong to the language proper, but it is still something
that has to be mentioned. Languages are used to write applications,
and these can use any language in the world. [[https://unicode-table.com/es/][Unicode]] is the way to use
any alphabet, and some [[http://www.omniglot.com/conscripts/natlangs.htm][neographies]] and emoticons, in our
programs. Luckily enough, Perl6 packs one of the best supports for
this; unluckily, Unicode is complicated /per se/, so we will have to
learn a bit of linguistics to understand how we, later on, are going
to handle this, which we will even if we write only for ourselves.

First important concept is the /codepoint/. A code point is pretty
much equivalent to a letter, although it can be a symbol or also a
formatting instruction such as Tab or Newline. Every code point
corresponds to a numeric combination, which is usually expressed in
hexadecimal; for instance, =0x2017= corresponds to the character =â€—=,
part of a table-drawing set. Every character also has a series of
attributes, including the category; this character belongs to the =Po=
[[https://en.wikipedia.org/wiki/Unicode_character_property#General_Category][category]],
meaning that it is /Punctuation, other/. The [[http://userguide.icu-project.org/strings/properties][properties]] include a
series of attributes such as the fact that they are numeric or can do
things like folding to a particular case or be joined to the next
character, or even if the direction they are written in. 

Characters are written as [[http://mathias.gaunard.com/unicode/doc/html/unicode/introduction_to_unicode.html#unicode.introduction_to_unicode.grapheme_clusters][graphemes]], and usually a code point
corresponds to a single written grapheme; however, in some cases code
points group to form a /grapheme cluster/, which is a set of code
points that constitute a grapheme; the most common example is letters
with marks such as Ã¡, but more complicated expressions might be
thought of. Or not, depending on your imagination. 

You write graphemes and grapheme clusters as /glyphs/, or letters. And
these are typeset, in a particular environment, using /fonts/. A font
is a set of mathematical formulae, yes, there is math involved, that
allows to render a particular letter in many different sizes and forms
such as italics or boldface. The fact that they are a formula, and
that you have to design formulae for every single glyph, means that
not all glyphs might be available in all fonts. Some fonts will have
all, or most of them, some of them not. And that, in turn, means that
some Etruscan letter such as this one ðŒš that renders beautifully in
your editor might show up as an x-marked rectangle or question mark
somewhere else, a console or a word processor. In fact, depending on
how you are reading this, you might not see the glyph I'm referring to
at all. Some other glyphs, like this jack of diamonds ðŸƒ‹, will not show
up on your editor or even in a PDF document. However, you will be able
to see it in most browsers. 

Your take away message here should that you need to know how to use
Unicode in whatever program you use, and that some particular
structures of the program, like operators or names, will use graphemes
with particular properties, probably something alphabetic-like. Also
that Unicode is complicated, but that you should better learn about it
as soon as possible, as in now. 
* The expressions

The first thing you need to know about a language, any language, is
how to compute things. Compute in the more general sense: combine
things to give other things. This, in general, is called expression,
which, also in general, is a bunch of symbols linked by *operators*. 

Generally, modern computer languages are able to work with many
different kind of symbols, and Perl6 is no exception. Let's start with
that.

** REPLs and how to use them as glorified calculators

A
[[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]]
is a Read-Eval-Print loop. it is a program included with most
interpreted languages, that presents a command-line prompt and into
which you can type expressions, and, later on, full statements. But,
for the time being, let's type


#+BEGIN_EXAMPLE bash
perl6
#+END_EXAMPLE

And we will be into a perl6 REPL into which you can type Perl6 stuff.

Let's try the simplest thing:


#+BEGIN_EXAMPLE perl6
To exit type 'exit' or '^D'
> sin(Ï€/2)
#+END_EXAMPLE

You will have to find a way to type that Ï€, by copy/pasting it from
some website or google or right this. It will return the sine of Ï€/2,
which, as you know, is 1. 

And this is cool, because only some languages are able to handle this
kind of expressions, and, even more, to use it correctly in math. But
you can do even more:


#+BEGIN_EXAMPLE perl6
sin(Ï€/2) +1
#+END_EXAMPLE

You can do that by copying/pasting, or else install =Linenoise=, a
command line that allows you to go back to previous command by typing
arrow-up. Do it with


#+BEGIN_EXAMPLE bash
zef install Linenoise
#+END_EXAMPLE

You can use the usual arithmetic operators =+,-,*,/= but Perl6 adds
two typographic operators, Ã· and Ã— (these ones are produced in the
Spanish keyboard with May+AltGr+ comma or period), like


#+BEGIN_EXAMPLE perl6
sin(Ï€/3) Ã— sin(Ï€/3) + cos(Ï€/3) Ã— cos(Ï€/3)
#+END_EXAMPLE

Or, even better


#+BEGIN_EXAMPLE perl6
sin(Ï€/3)Â² + cos(Ï€/3)Â²
#+END_EXAMPLE

One of the objectives of Perl6 is to use the whole range of characters
that Unicode, if not modern keyboards, offer. This simplifies
expressions and makes them more readable. 

You will not find all numbers in superscript mode. If you want to
raise a number to the /x/th power, use =**=.
#+BEGIN_EXAMPLE perl6
3**25
#+END_EXAMPLE

Arithmetic only takes you so far in programming. We will learn how to
deal, and operate, with all kinds of data in this glorified
calculator. 

** Now that we mention Unicode

Unicode is the way to express all alphabets in the world, and then
some things that are not really alphabets. It uses up to around sixty
thousand symbols, and allows us to write, using modern operating
systems, editors and languages, anything that would have to be
expressed in living or dead languages, and even some
emoticons. Unicode is evolving constantly, and for the people means
that they will be able to use characters that are usual in their own
language, and also some usual in mathematical expressions. 

Since not all languages, editors, operating systems or even keyboards
are *modern* in that sense, some impedance should be expected. But
Perl 6 will not get in your way, allowing you to use them just they
way they should, so if you want to raise something to the second power
you will not have to, although you can, write x**2 but simply xÂ².

** It's not only numbers

All the expressions written above are numbers. 


#+BEGIN_EXAMPLE perl6
(sin(Ï€/3)Â² + cos(Ï€/3)Â²).WHAT
#+END_EXAMPLE

is going to return =(Num)=, indicating that it is simply a Number,
actually a real number. This =.WHAT=, together with surrounding the
expression via parentheses meaning grouping, is a way to apply a
/property/ or to call a /method/ on that object. In Perl6, everything
is an object, and objects have a class, and you want to call methods
that correspond to objects of that class, append a dot and use the
method, possibly with some arguments like =WHAT(is, "the",
$what)=. Let's not worry about that for the time being, or about
classes themselves. Just with the fact that every expression is an
object, and those objects belong to a class; every class in Perl6
/descends/ from the ur-class called Î¼ or =Mu=. And among the
[[https://docs.perl6.org/type/Mu][properties of Mu]] is that you can call this =WHAT=. Any other class
descends from this one, so /you can call =.WHAT= on any object of any
class/. That is the take-home message, even if you might not know, so
far, what is an object, or a class. Second take home message:
/different objects also have different classes/. 

Since both /objects/ at the sides of the =+= are Nums, you
can add or subtract them or do any other arithmetic operation, but you cannot do 


#+BEGIN_EXAMPLE perl6
sin(Ï€/3)Â² + cos(Ï€/3)Â² + " is 1"
#+END_EXAMPLE

will yield this error
#+CAPTION: Errored expression in the REPL
#+NAME:   fig:chap2-expression
[[./img/expression-error.png]]

And the reason for that can be found out by typing:
#+BEGIN_EXAMPLE perl6
" is 1".WHAT
#+END_EXAMPLE

Which, whatever it is, is not a =Num=, so it cannot be added. 
That shows that there are more types of data you can use and work with
from the REPL. In fact, there are a lot. In general, you cannot mix
and match and, also in general, every one has got its own operators
you can work with. You can mix fractions with integer numbers, for
instance: 

#+BEGIN_EXAMPLE perl6
 â…“+4/3
#+END_EXAMPLE

And 

#+BEGIN_EXAMPLE perl6
(â…“+4/3).WHAT
#+END_EXAMPLE

will return =(Rat)=, a Rational, same as =â…“+4=. In fact, most
[[http://blogs.perl.org/users/ovid/2015/02/a-little-thing-to-love-about-perl-6-and-cobol.html][floating point numbers in Perl 6 will be represented as rational]],
unless we explicitly tell the interpreter to deal with them as
floating point, that is real, numbers, which, BTW, cannot be something
else that fractional numbers since they use a finite representation in
computers. Mostly.

However, in some cases you can try and mix different things using an
operator. Operator "~" concatenates stuff, that is, joins things that
look like words and letters, for instance

#+BEGIN_EXAMPLE perl6
6 ~ "6"
#+END_EXAMPLE

will return =66=, and anything you put there will be concatenated. =~=
is an operator that is not picky about what it has got in both ends. 

You cannot add strings together, because that is what they are, but curiously enough, you can multiply them:

#+BEGIN_EXAMPLE perl6
"1" ~ "\n" ~ "2" x 2 ~ "\n" ~ "3" x 3 ~ "\n" ~ "2" x 2 ~ "\n" ~ "1"
#+END_EXAMPLE

This being a rather nice and utterly useless example on the operator
=x=, which /multiplies/ or rather /replicates/ whatever character of
string it is related to. Introduced together with =\n", the carriage
return, so that if forms a nice pile of stuff. 

Which is shorter and better in this example

#+BEGIN_EXAMPLE perl6
for <1 2 3 2 1>  { say $_ x $_ }
#+END_EXAMPLE

but that's something we will see later on, when we talk about loops
and all that's nice and beautiful about it. 

** Lists of things are also game.

Numbers and words are simple things. But you can string them together
in something more complex. You can have sets of them, or lists of
them, or combine them as sets of lists of sets of whatever. Perl 6 is
great because you do not need to make all things in a complex
structure be of the same type. You can create a list with the less than
and more than sign, this way:

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²>
#+END_EXAMPLE

And with lists, you can do things like sorting:

#+BEGIN_EXAMPLE perl6
sort <a b 7 â…“ Ï€Â²>
#+END_EXAMPLE

or combine lists to create a new one using the =X= operator, called
*cross product* 

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²> X < â†’ â† >
#+END_EXAMPLE

You can also combine in some other ways, adding one list to another. 

#+BEGIN_EXAMPLE perl6
<a b 7 â…“ Ï€Â²> , < â†’ â† >
#+END_EXAMPLE

The simple /comma/ operator is going to create a new list with two elements, each one of which is
a list. You can *flatten* it:

#+BEGIN_EXAMPLE perl6
flat <a b 7 â…“ Ï€Â²> , < â†’ â† >
#+END_EXAMPLE

You can already do interesting things with these lists (or arrays, or
vectors, stuff in a row, whatever). For instance, you want to pick one
element randomly, 
#+BEGIN_EXAMPLE perl6
 (flat <a b 7 â…“ Ï€Â²> , < â†’ â† >).pick
#+END_EXAMPLE
will return, every time you run it, a different element. You can do
that as many times as you want, but it is much easier to use =roll= to
do it many times for you.
#+BEGIN_EXAMPLE perl6
< â†’ â† >.roll(6)
#+END_EXAMPLE
will return a whole quiver of arrows.

Maybe you want a single element of the array:
#+BEGIN_EXAMPLE perl6
 < â†’ â† >.roll(6)[3]
#+END_EXAMPLE
This will return the 4th element, taking into account that all arrays
start with 0. Otherwise known as a random arrow. Or you might want to
extract a range
#+BEGIN_EXAMPLE perl6
(flat <a b 7 â…“ Ï€Â²> , < â†’ â† >)[3..6]
#+END_EXAMPLE
uses the /range/ operator =..= (that is, two points), which generates
a contiguous sequence of elements. Otherwise known as, well,
range. But these ranges also behave as arrays:
#+BEGIN_EXAMPLE perl6
(0..10)[3..6]
#+END_EXAMPLE perl6
although they are not exactly the same:
#+BEGIN_EXAMPLE perl6
(0..10).WHAT
#+END_EXAMPLE perl6
will, effectively, return =(Range)=. 

This is just the start of complex structures with Perl. More to come
in the next chapters. 

* Î³ - Thinking like computers do
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You probably know, or at least have made an educated guess, that computers are unlike humans. But since
expressions are entered in pretty much the same way you would use
somewhere else, it's no big deal. However, once you want to
deconstruct what actually needs to be done to make a computer do
whatever you want it to do, you have to start to think like a
computer, in what is known as computational thinking. It is kind of a
game of "Simon says". You have to precede every instruction you give a
computer by something that indicates you want it to do precisely that,
and then you have to say very precisely what it needs to do.

But there is more to that, the fact that you also need to indicate the
/sequence/ of actions you want the computer to do by indicating that
in your program. When you work with the REPL, as we have done above,
the sequence is quite clear: you say something, press Enter, the
computer thinks for a while or what looks like nothing, you have the
response. However, when the program gets a bit more complicated, you
also have to think, in a particular point in time, where the computer
might be and what that implies regarding values or results you need to
proceed. 

Which is why we talk about
[[https://en.wikipedia.org/wiki/Computational_thinking][computational thinking]] as a series of techniques for solving problems
using computers, including all the steps you need to take to identify
the problem, put it in a way that can be understood and processed by a
computer, and then express every step as instructions in program that
will, eventually, solve the problem. 

We will get back to this later on, but for the time being there are a
couple of techniques you will need to understand. First is /pattern
recognition/, which means finding what several different pieces of
information have in common and, in turn, what to do to solve a problem
in a case given that you know how to solve it in another case which
follows the same pattern. When you find something that has a regular
increasing or arithmetic pattern, for instance, you will discover that
you can use lists or sequences to solve it, and apply whatever you
know already on how to deal with sequences. 

The second technique we should focus on right now is /problem
decomposition/, how to break down a problem in different parts that
can, more easily, solved. For instance, you want to find what would be
the number a sequence will reach if left to grow until infinity; first
you will have to solve the problem of representing the sequence, which
might not be immediate, and then how to apply known techniques of
limit finding, such as
[[http://tutorial.math.lamar.edu/Classes/CalcI/LimitsProperties.aspx#Limit_Props][finding the function that represents the sequence]] and then applying
what is known about function limits to that sequence. 

Every part of a problem will eventually become an instruction or
group of instructions called usually /subroutines/ or /functions/. But
for the time being, it is enough to know that breaking down a problem
in parts you already know how to solve is the key for solving problems
of any size. 

* To infinity and beyond

If you know in advance every single term of a list, writing them down
as above is the way to handle them. However, you might know a few
terms of the lists, or how they are generated, and that is that. Let
us see how to deal with them in Perl 6

** Working with ranges and sequences

For long lists, you might want to use only the first and last term 

#+BEGIN_EXAMPLE perl6
1...222
#+END_EXAMPLE

via the *yada, yada, yada* operator, or, even better,

#+BEGIN_EXAMPLE perl6
1 â€¦ 333
#+END_EXAMPLE

But the coolest thing with lists is the stuff you can do to all of
them at the same time:

#+BEGIN_EXAMPLE perl6
[+] 1 â€¦ 333
#+END_EXAMPLE

will add everything together. Any operator you put inside brackets
will be applied to all in turn. Try =[*] 1 â€¦ 333=, for instance.

But the coolness factor can be increased:
#+BEGIN_EXAMPLE perl6
[+] 1,3 â€¦ 333
#+END_EXAMPLE

and even
#+BEGIN_EXAMPLE perl6
[+] 1,3,9 â€¦ 333
#+END_EXAMPLE

The =[]= is called a /reduce/ operation. If you have heard some big
data buzz, you have probably heard about an operation called
*map/reduce*. Well, this is the /reduce/ part. And it is so easy to do
with Perl6.

Because Perl6 is able to deal with arithmetic and geometric progressions out
of the box. And even infinite ones:

#+BEGIN_EXAMPLE perl6
1,3,9 â€¦ âˆž
#+END_EXAMPLE

You can obtain the 100th term using

#+BEGIN_EXAMPLE perl6
(1,3,9 â€¦ âˆž)[100]
#+END_EXAMPLE

or, why not, the terms from 1000 to 1100

#+BEGIN_EXAMPLE perl6
(1,3,9 â€¦ âˆž)[1000â€¦1100]
#+END_EXAMPLE

which will return a pile of numbers, separated by spaces. It is quite
usual to start from 0 and go to a particular number. The /caret/ = ^ =
is used to indicate /0 to/ the number that follows it

#+BEGIN_EXAMPLE perl6
(0,5,10 â€¦ âˆž)[^25]
#+END_EXAMPLE

will list the 25 first elements of the list of multiples of 5. 

 Besides, at the same time, we have seen how to deal with a single term in a
list, and how to work with a series of terms. You can use infinite
syntax to generate also finite lists if you do not want to compute in
advance the precise terms of it. For example, above you will be
working on the 1000th term and on of an infinite list, without working
out if it is exactly 3000 or some such. You can check out
[[https://perl6advent.wordpress.com/2010/12/04/the-sequence-operator/][this Advent calendar entry for a few samples of Perl6 coolness too]].

** Operating on lists
Lists are perfectly good subjects for this calculator on steroids we
have in the REPL. Whatever combination you think about, it is probably
possible to do it on lists; some of them will work also on infinite
lists, but most probably not. We have already seen =[+]= work on a
list of numbers. Any sensible operation like =[*]= will also work. But
this will also yield a result:
#+BEGIN_EXAMPLE perl6
[~] 'a'..'z'
#+END_EXAMPLE
collating together all elements in the alphabet. Preceding it with
=\=. which you can think of as an accumulator, will instead create
another array whose elements are the accumulation of the operation up
to that element. Better if you try it:

#+BEGIN_EXAMPLE perl6
[\~] 'a'..'z'
#+END_EXAMPLE

This can be very useful when working on accumulative series, for
instance, what is the sequence of factorials up to 25?
#+BEGIN_EXAMPLE perl6
[\*] 1..25
#+END_EXAMPLE

This accumulator is called a /zip/ operator. We will see later on what
it actually means, for the time being it just makes operating with
series a bit easier. 

But single lists only take you so far. Previously we have seen the
comma for kind-of joining two lists. But there are multiple ways of
creating new lists by combining them. For instance, the /cross/
operator =X= will create a list of lists from two of them
#+BEGIN_EXAMPLE perl6
(1,3...10) X (2,4...10)
#+END_EXAMPLE
will combine all even and odd numbers in pairs, combining 1 with 2 to
10, then doing the same with 3... This can be useful if you want to
create a combination, but even more so if you turn =X= into a
hyper-operator by using it to precede any operation such as =*= 
#+BEGIN_EXAMPLE perl6
(1,3...10) X* (2,4...10)
#+END_EXAMPLE
will create a /flat/ list with the results of multiplying the pairs we
have generated before. This can be useful for complicated arithmetics,
but sometimes we only want to pair a couple of lists to create a new
one that takes one element from each one, combining them like the
tooth of a zipper. This operation is appropriately named Zip and
represented by =Z=
#+BEGIN_EXAMPLE perl6
 (5,10...Inf)[^20] Z (4,8...Inf)[^20]
#+END_EXAMPLE
This creates a new list that zips together similar terms in the
sequence of multiples of 4 and 5. Can we multiply them to create a
succession of multiples of 20? Maybe...
#+BEGIN_EXAMPLE perl6
 (5,10...Inf)[^20] Z* (4,8...Inf)[^20]
#+END_EXAMPLE

** Doing stuff to lists
Well, that is precisely what we have been doing above. But we need to
do more. A lot more. 

All we have been doing is combining lists with each other. We have
also been using lists of exactly the same length. But we might need to
do some basic operation to a list, or create one list that is not
exactly an arithmetic or geometric progression. For instance, this
#+BEGIN_EXAMPLE perl6
 (1/2,1/3...Inf)[5]
#+END_EXAMPLE
will not do what you expect it to do, which would be 1/5. Writing the
whole range
#+BEGIN_EXAMPLE perl6
 (1/2,1/3...Inf)[^5]
#+END_EXAMPLE
will show that, what it is actually doing is to turn it into an
arithmetic sequence that subtracts 0.166667 from the previous one,
despite being relatively clear, for a human, that we are trying to
create the =1/n=. Succession. We can do that, however, using the
hyperoperators =<<>>= and derived. Check this out
#+BEGIN_EXAMPLE perl6
1 <</<< (1..100)
#+END_EXAMPLE
will return precisely what we are looking for, a descending sequence
of numbers that ends with 0.01. Please note that we can no longer use
an infinite (lazy) sequence: we have to be concrete. 

This =<</<<= is known as an hyperoperator, because it takes a humble
operator like =/= and turns it into a machine that deals with
lists. It can also be written =Â«/Â«= with the direction of the angular
brackets pointing at the /smaller/ thing, in this case a single number
vs. a list. 

What happens if you do
#+BEGIN_EXAMPLE perl6
 <1 2> <</<< (1..100)
#+END_EXAMPLE
is kind of funny. It is like applying the cookie cutter in the left
hand side to the right hand side: the first element will be divided by
1, the second by 2, and so on... You can even take one wing =<<= from
the hyperdrive, and use it to, for instance, negate a sequence:

#+BEGIN_EXAMPLE perl6
-<< (1..100)
#+END_EXAMPLE

When the two lists have the same length, the arrows can go in any
direction, it will not matter much. Let us create random fixtures for
a (subset of) the Premier League
#+BEGIN_EXAMPLE perl6
( <ARS AST BOU CHE EVE LEI LIV MCI MUN NEW>.pick(10) 
  Â«~Â» 
    ( " - " Â«~Â« <ARS AST BOU CHE EVE LEI LIV MCI MUN NEW>.pick(10))) 
    Â»~Â» "\n"
#+END_EXAMPLE
This, which could admittedly be a little shorter, uses these
hyperoperators to combine acronyms so that they are separated by a dash,
which is what = " - " Â«~Â« = does, and then put the whole result in
different lines, which is done by the = Â»~Â» "\n" = in the last line. A
great achievement, with a small amount of coding involved. We are
using throughout the =~= string concatenation operator, which is what
allows us to create such a compact statement. 

* Î´ - Working as a team
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  

You will never walk alone when solving a problem. Even if you are
working in a side project, something you thought about yourself, you
will need an easy way to keep track of changes and also to easily
incorporate whatever suggestions or even changes somebody else might
be doing to your code. And that easy way is to [[https://git-scm.com/][use git]]. =git= is
described as a distributed source code manager, but it is much more
than that, it is a way of life. =git= organizes code in
/repositories/, pretty much corresponding to projects, but including
also artifacts such as documentation, manuals and examples. 

As a way of life, it needs much more than a single section in a
book. You will eventually learn as you go, but for the purpose of
this, let us say you have opened an account in an online Git server
such as [[http://github.com][GitHub]]. GitHub is free for public repositories, and even for a
few closed ones if you are a student. If you do not feel comfortable
with this, do not worry, you can use [[http://bitbucket.com][BitBucket]], which allows private
repositories with some limitations on the number of users and number
of repos.

Be that as it may, you will need a repository to store all the files
that you will be writing in this, maybe also your course notes. It is
going to be fun start to create a single program, and keep changing it
over the same file; git will record changes and you will be able to
track your own progress over this file. In order to do that, create a
repository or project in any of them, and 
choose a sensible free software license, as well as Perl as a language
(closest to Perl6) and also generate a =README.md=, which is in
Markdown. 

That creates a git repository in whatever computer hosts GitHub (or
BitBucket), but git is a distributed system, and you can synchronize
your computer with the contents of the repository out there. Bring it
down with 

#+BEGIN_EXAMPLE perl6
git clone https://github.com/yourname/yourrepo
#+END_EXAMPLE

and please note I am using =https= here. You can also use the /ssh/
address and in fact you should, but for the time being let us let it
be. Remember to take down the username and password you have used,
because you will need later on.

That command will create a =yourrepo= directory hanging from wherever
you are. Change to it with =cd yourrepo= and start working there. For
instance, create a new file with =touch a_new_file=. Not everything in
the directory is /in/ the repository, you have to purposefully add to
it. 

#+BEGIN_EXAMPLE perl6
git add a_new_file
#+END_EXAMPLE

* Thinking logically

You are going to need in many cases to check whether something is true or
false: check if a file exists, check if a number is bigger or smaller
than another, or even check if a complicated logical proposition is true
or not. In fact, everything in computers uses logic, to the point that
all information is codified using true or false values; a single true/false value is called
a /bit/. There are so many layers over that single bit that you do not need to be
much concerned about them, but you need to know about expressing and using logic
in programs, and specially in Perl 6, which is what we will deal right next. 

** The truth is...

"Out there". "I am your father". All of these things together. Well,
truth is =True= and false is =False= in Perl6. However, there are
other things that are also true, or not, depending on the context,
because, as we have seen before, the types and thus the real value of things flow and change
depending on the context. Fortunately, we have a handy operator that
asks any and everything if it is true or not: =?=.

So let's see what kind of things are true or not:
#+BEGIN_EXAMPLE perl6
?<< ("","False",0,1,333,0.5)
#+END_EXAMPLE
will show us two =False=s; the "" and the 0. So empty strings and void
numbers are equivalent to false. Also empty arrays, check out =?()=,
while non-empty arrays are =True=. Besides, we are using here,
similarly to what we used before, a single operator applied to all the
elements in a list, which we surround with parentheses and sprinkle
with commas since they are of different types: strings and
numbers... This operator will apply, to every single member of the
list, the /unary/ operation =?=. That is akin to doing =?""= and so
on, until the end of the list. Perl6 saves typing and frees us from
metacarpal tunnel syndrome. 

And what you can ask, you can negate:
#+BEGIN_EXAMPLE perl6
!<< ("","False",0,1,333,0.5)
#+END_EXAMPLE
will result exactly in the opposite. =!= negates the expression it is in
front of. By the way, these operators that are /in front of/ are
called prefix operators; since they operate in a single element they
are also /unary/, but that goes without saying if they are prefixing
something. Operators in the middle of two things are called /infix/
and they happen to be /binary/. Finally, there is also a /ternary/
operator, but we will get to that soon.

So, finally, =?True= is =True= and =!True= is =False=. And there is
no bigger true than that. So

#+BEGIN_EXAMPLE perl6
so "this"
#+END_EXAMPLE
is =True= and
#+BEGIN_EXAMPLE perl6
so ""
#+END_EXAMPLE
is, obviously, =False=.

** Comparing things

Affirming and negating is a great way to learn philosophy, but we need
a bit of arithmetic too. Let's see how Perl6 performs simple comparison operations

#+BEGIN_EXAMPLE perl6
3 > 2
#+END_EXAMPLE

will return =True=, 

#+BEGIN_EXAMPLE perl6
2 == 3
#+END_EXAMPLE

will return =False=, because 2 is not equal (==) to 3. Remember, == is
used for comparison, and the rest of the operators are quite
usual. Whenever an operations can be true or not, it will return a
=False= or =True= value, and all these comparison operations
are. This equality operator is quite smart

#+BEGIN_EXAMPLE perl6
2 == 3
#+END_EXAMPLE

will return =False=, but

#+BEGIN_EXAMPLE perl6
2 == "2"
#+END_EXAMPLE

will return =True=. The /smartness/ of the operation means that it
will be able to recognize something even across different types, as in
this case, where we are comparing a number (or =Int=) with a =Str=. It
is even smarter

#+BEGIN_EXAMPLE perl6
3 == â…¢
#+END_EXAMPLE

because it understands, as in this case, Roman numerals. 

There is also =~~=, which is kind of an universal matching, equivalent
to /is a kind of/. It behaves as == when the type is the same,
although

#+BEGIN_EXAMPLE perl6
3 ~~ "3.0"
#+END_EXAMPLE

will return =False=. = 3 ~~ Int =, however, will be =True=. 

All these equality operators have a dark side which does exactly the
opposite. We have seen before that =!= is the negation of all that's
True, so, effectively, != will mean /not equal/ and !~ /does not
match/. Check it out, it is really true. That it is that way, I mean. 

In case you are working
with strings, =>= is not going to work, with ="a" < "b"= yielding an
error that tells you it cannot convert a string to a number; it will
work, though, for ="10" < "011"=, but after turning them into numbers;
alphabetically, "011" goes /before/ "10". That is why there are
specific operators for strings, whose names are
built as acronyms of the operation, for instance, =ge= for /greater
than or equal/, as in 

#+BEGIN_EXAMPLE perl6
"aardvark" ge "bee"
#+END_EXAMPLE

This will take into account the lexicographical order, which is kind
of like the alphabetical, but taking into account ordering in
Unicode. Thus

#+BEGIN_EXAMPLE perl6
"Ï" le "Î¡"
#+END_EXAMPLE

because apparently small letters go /after/ capital letters, but
#+BEGIN_EXAMPLE perl6
"áš™" gt "ïº¶"
#+END_EXAMPLE
because, well, that is the way it is. 

** And filtering them

Now that we know how to deal with truths and untruths, we can use this
knowledge to deal with sequences and filter them depending on whether
a condition is true or not. We can, for instance, use ready-made
functions such as =is-prime= 
#+BEGIN_EXAMPLE perl6
(2000..2100).grep( { .is-prime} )
#+END_EXAMPLE
As you might remember, putting parentheses around an expression, in
this case a =Range= (remember, two periods) turns it into an /object/
and thus something that is amenable of using some methods. [[https://docs.perl6.org/routine/grep][=grep=]] is
one of them: given a list, applies an expression to every member of
the list returning another list with only the elements where the
expression is true. The expression which is surrounded by curly
braces, as you see, is between 
parentheses, and since every element is treated as an object by itself
by =grep=, the =.is-prime= way of writing it indicates that you are
taking the first element, applying the =is-prime= function, select
that element for the result if it is true, and so no. That expression
above tells us the number of prime years (not premium years) in this
century. How many are there?

What there is is many ways of writing that. To reduce clutter, Perl6
allows also the parentheses to be suppressed.
#+BEGIN_EXAMPLE perl6
(2000..2100).grep: { .is-prime} 
#+END_EXAMPLE
by a colon. And you can also invert the way of dealing with this,
putting =grep= at the forefront
#+BEGIN_EXAMPLE perl6
grep { .is-prime}, 1..Inf
#+END_EXAMPLE
and, right there, you have the list of all prime numbers. Which one is
the number 1000th? (it might take a while).

In fact, if you are applying a single method that takes only one
parameter, such as the one above to every
element, there is an
[[http://blogs.perl.org/users/zoffix_znet/2016/02/perl-6-shortcuts-part-1.html][even simpler  way of doing it]]:
#+BEGIN_EXAMPLE perl6
(0,Ï€/2,Ï€,3*Ï€/2,2*Ï€)Â».sin
#+END_EXAMPLE
Using the parentheses and commas we create an array, and the =Â».=
construction will apply the operation behind to each and every member
of it, returning the sine of all these angles. Any operation with a
single operand you can think of can be applied, in this way, to a
whole array of things. Which is cool. Even cooler, you can use the
=so= we learned above to filter only those whose cosine is not zero:
#+BEGIN_EXAMPLE perl6
grep { .so }, (0,Ï€/2,Ï€,3*Ï€/2,2*Ï€)Â».cos
#+END_EXAMPLE
This might work with precision in the future, but for the time being =cos= is pretty
close to 0, but not exactly 0, so =grep= actually returns all elements
of the array, which are effectively non-zero. 

You might do simpler things to arrays, like computing the minimum:
#+BEGIN_EXAMPLE perl6
min (3/4, 5/6, 3/8, 2/3)
#+END_EXAMPLE
or even computing whether an element is or not in a particular array,
#+BEGIN_EXAMPLE perl6
 332 âˆˆ  (7,14...2000)
#+END_EXAMPLE
using =âˆˆ=, which is the mathematical symbol for /belongs to/ and returns
False in this case. That can be an
easy and straightforward way of finding out multiples, for
instance, or if an element is included in a more complex
sequence. Multiples that [[https://trizen.gitbooks.io/perl6-rosettacode/content/programming_tasks/F/Filter.html][you can also extract using =grep=]] 
#+BEGIN_EXAMPLE perl6
(1..100).grep(* %% 7)
#+END_EXAMPLE
where, in this case, =*= is a stand-in for the element in the list, which we had
not used before in this way; we had used it before as the end of a sequence
meaning /everything/. This is pretty much the same, /everyone/. Perl6
reuses symbols like this in different contexts, but at the same time it
gives them similar, or the same, meaning. That is good and well and
saves you from learning lots of different squiggles for stuff that
pretty much does the same. 

** This and that. Or that.

Checks pile up to form a pyramid in which whatever emerges as true or
false at the top depends on what happens at the bottom. Sometimes it
is enough with one of the conditions holding, sometimes you need all
the conditions to hold at the same time.  These are the logical
operators, which are called =AND= and =OR=. ANDing two premises holds
true only if both are true, ORing them is true as long as one of them
is.

#+BEGIN_EXAMPLE perl6
(7 > 1) && (7 < 10)
#+END_EXAMPLE
is =True= since both inequalities hold; also 

#+BEGIN_EXAMPLE perl6
True || (7 < 10)
#+END_EXAMPLE
is True.

But what happens if we want to do something when an expression is
true, and something different when it is false? Could we put all that
in an expression. Well, yes:
#+BEGIN_EXAMPLE perl6
(3 > 2)??"Bigger"!!"Smaller"
#+END_EXAMPLE
The ternary operator is one of the few that deals with three
arguments. The first one, before the =??=, is an expression that can
be true or false, or, actually, any of the equivalents we have seen
above. If it is true, then the result will be what is between the =??=
and the "!!". If it is not, then what is left, what we find behind the
=!!=. What will it be in this case? Check it out and you will see.

This operator is quite useful, and fast, when you want to check
alternatives in a single sentence. For instance, checking types
#+BEGIN_EXAMPLE perl6
("3".WHAT ~~ (Str))??"Tres"!!3
#+END_EXAMPLE
This will return =Tres=, since "3" is actually a string. Remember that
you have to use the parentheses to wrap around teh expression, almost
always. 

You will find these expressions later on in many places. It is worth
the while to devote a while to test them so that you end up knowing
perfectly how they work and what to do with them.

** Back to infinity. And beyond.
Now that we got the hang of expressions we can go back again to these
infinite sequences we are so fond of. What we have seen so far are
sequences that are either infinite and thus ended with * or âˆž or
finite ending with a particular number. But we know now how to add
conditions, right? Let's use them in definition of sequences.
#+BEGIN_EXAMPLE perl6
11,22 ...  * %% 7
#+END_EXAMPLE
Where before we had the asterisk or =Whatever=, now we have a
/condition/. When =True=, the sequence will end. In this case, when it
arrives to 77. Maybe we want it to end right before that, in which
case we use the /up to, but not including/ operator, the dots plus a
caret
#+BEGIN_EXAMPLE perl6
2100,2200 ...^ * %% 400
#+END_EXAMPLE
Will yield the years ending a century, in this millenium, that [[https://en.wikipedia.org/wiki/Century_leap_year][are not]] a leap year, since
only those that can be divided by 400 actually are leap year. 

This is but a simple example, but it allows you to see the flexibility
of the language and how some types of expression, logical expressions,
can be applied to other part, defining sequences. 

* â€ŽÎµ - The command line
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

# This is the beginning of the session 

In the principle was the command line. 

That is so true. You run
scripts from the command line, and you go back to it when you are
done. But also the Linux was created with a set of command line tools
that can be integrated with your program to save you typing and
thinking and energy. There is so much you can do with it, that we will
need to know how it works, starting with organization of the disk
drive. 

The disk drive is nowadays mostly solid-state, or else it is so fast
you do not need to worry about it. Anyway it is organized like an
inverted tree, with the =root= at =/= and all branches and leaves
hanging from it. That tree would branch on /directories/ or /folders/
and the leaves hanging at the far end would be /files/. In Linux,
branching is marked by =/=, so a file /this.is.a.file/ in a folder called /jj/ which is
inside another folder called /home/ will be completely qualified by
=/home/jj/this.is.a.file=, or, sometimes, using web-style universal
resource identifier, =file://home/jj/this.is.a.file=. The characters
beyond the last period are usually called the /extension/. They are no
big deal, actually, just a part of the name, but they usually have a
conventional value for particular kind of files, like =.txt= for text
files and things like that. 

When you are working from the command line, you are always in a
particular directory, which is called the /working/ directory. You
probably have used [[https://github.com/Bash-it/bash-it][Bash it]] or something like that to show it on the
command line; if you have not, well, do it now. =cd= is used to change
this working directory, and you can use absolute names or
abbreviations like =..= for the directory that contains your current
working directory. 

We have already seen a few things the operating system can do,
including the command /shell/, or command interpreter, which includes
some orders and also fetches program for you to run, and also
editors. But there are a few more orders that will be invaluable when
using Linux as a programmer.

** Calling names

Sometimes you need to refer to lots of things at the same time, like a
bunch of files with a common characteristic or simply all of
them. Linux, in the same way as all modern operating systems, has a
way of using /wildcard/ characters to mean "lots of things". The most
widely used is the /asterisk/ =*=, also the Kleene star for some
obscure reason. Anyway, when you find =*= in an expression it means
/whatever/. As in =ls *= means /list whatever stuff is in this
directory/ or =ls ../*= means /list whatever stuff is in the directory
right above this one/. 

You can combine it with other characters. =a*.p6= will mean all files
whose name starts with =a= and has the =.p6= /extension/, since
whatever goes beyond the last dot is usually called /extension/ and
usually is peculiar to a kind of files, such as the Perl 6 files in
this case. 

There are [[http://www.linfo.org/wildcard.html][more powerful wildcards]] and many ways of including and
excluding particular files. It will help you to know them, but for the
time being this wildcard characters is all you need. 
** Moving stuff around

=cp=, as in "copy" copies files to another directory, maybe with
another name

#+BEGIN_EXAMPLE bash
cp this.is.the.original.file ../to/this.is.a.copy
#+END_EXAMPLE

will copy the original file to a directory called =to=, and with a
different name. =..= is the upper directory. Similarly,
 
#+BEGIN_EXAMPLE bash
mv this.is.the.original.file ../to/this.is.a.copy
#+END_EXAMPLE

will /move/ or change the name of the file, that is, copy and also
remove the original file. If you just want to get rid of a file =rm
file= will do it. 

** =find= 

Used to find files by name, it is invaluable when you do not remember
exactly where you downloaded your repo or you want to find an example
of a file you have already done in the past. For instance, typing this
in the command line

#+BEGIN_EXAMPLE bash
find /home/thisisme -name "*.pl6" -print
#+END_EXAMPLE

will return all files with the extension =pl6=, which is the usual one
in Perl6, in your home directory, as long as your username is
=thisisme=; change it to your username to apply it to your particular
situation. 

=find= is, then, kind of like =ls= on steroids. =ls= will return the
files in your folder, or if you do =ls -alt= will return them sorted
by date, which is useful when you do not remember the last file you
were working with. It happens.

** =grep=

You do not remember in which particular file you used a name like
=foo=? =grep= to the rescue

#+BEGIN_EXAMPLE bash
grep foo *.pl6
#+END_EXAMPLE

will look for your =foo= in all files with the extension =c=.

** Creating and destroying things

=mkdir= creates directories, =mkdir -p this/is/a/deep/directory=
creates a /leaf/ directory and all the rest, and =touch= creates empty
files. 

You can also use the so called /redirections/ to create files from the
output of other things. For instance 
#+BEGIN_EXAMPLE bash
ls *.pl6 > all-perl6-files.txt
#+END_EXAMPLE
will create a file that contains the names of all files with that
extension, check out the use of the wildcard =*= discussed just above, while 
#+BEGIN_EXAMPLE bash
touch I_am_touched
#+END_EXAMPLE
creates an empty file. Which, by the way, can be incredibly useful
things. If the file is created, it is /touched/ in such a way that it
is as good as new and will appear first when you list the directory
with `ls -alt`, which is the way all directories should be shown. 

Finally, here is something that you should use sparingly, if ever. =rm
-rf stuff= will delete the directory subtree that starts with
=stuff=. And once things have been deleted, they are deleted for ever
in Linux. So be careful, and always backup. 


# This could be the end of the session

* Pack all your troubles in a bag. And a set. 
Perl6 is, intentionally, designed for math, so it includes some
representation for data that can be found usually in math courses. Not
only that, it can work with them just in the way you did in your
school math class, using the same symbols. For instance, let's talk
about Sets. And later, we will talk about the type that gives some sense to this chapter's title: Bags. 

** What is a set and what can it do for me.

A set is a group of things whose order does not matter much. 
#+BEGIN_EXAMPLE perl6
set(1,â…“,"foo",{ $^Ã¾ %% 3})
#+END_EXAMPLE 
Superficially it is similar to an array, with the parentheses and all,
but it /does/ need the word =set= before it. In fact, you can easily
turn an array into a set, as long as it is a finite set and not an
infinite one. 
#+BEGIN_EXAMPLE perl6
set(^1000})
#+END_EXAMPLE 

Sets can be used for baskets, or shelves, or groups of people... When
order does not make a logical sense, and you are more interested in
knowing if something belongs to a set or not, =Set= is the kind of
structure you must give your data. Which might be handy in cases such
as this one
#+BEGIN_EXAMPLE perl6
127 âˆˆ  set(7,14...1000)
#+END_EXAMPLE 
which is a very compact way of checking if 127 is, or not, multiple of
seven and will return false, which means that
#+BEGIN_EXAMPLE perl6
127 âˆ‰  set(7,14...1000)
#+END_EXAMPLE 
will obviously return =True=

** Sets coming together

One cool things about sets is that you can use them as a single thing
with several values at the same time. These are called [[https://docs.perl6.org/type/Junction][Junctions]] and
only correspond to a single logical value if you evaluate them to
return true or false. 
#+BEGIN_EXAMPLE perl6
all <innie minnie moe 0>
#+END_EXAMPLE 

# Continue with other set stuff

* ×‘â€Ž - Secure connection
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

The whole point of programming is working with remote computers. And
in fact it is almost impossible that you work nowadays without using
several remote computers, /cloud/ hosts as it were, to perform routine
tasks. You need to connect to them, and do so efficiently and also
securely. That is why /ssh/ was invented.

* Changing things

We have already seen how built-in functions operate on data and
extract information from them or change them in different ways. In
fact, operators such as =*= are nothing but functions in disguise,
with 3 + 4 actually being actually =adds(3,4)=. Anything that operates
or changes things, converting them into others, is a /function/,
although if they use funny symbols we will call them operators. 

It is going to be a lot of fun if we can build our own, right? Let's
do exactly that. 
#+BEGIN_EXAMPLE perl6
{ $_ * 2 }
#+END_EXAMPLE
is a piece of code that will multiply by two whatever gets handled to
it. The giveaway that turns it into a function are the curly
brackets. Putting funny symbols that enclose, or close, other symbols
has been used quite frequently, using quotes, or angle brackets, or
parentheses to enclose arrays or lists or strings. The first giveaway
here are those curly brackets. And the second is the =$=. Functions
have to operate on something, right? So this =$_= (dollar, underscore)
will be a /stand-in/ for whatever the function is going to operate
in. In fact, you dont need this =$_= to actually make a function;
curly brackets are more than enough, but ={ 42 }= would be a boring
function that just returns the answer to life, the universe and
everything. Let us find out how Perl6 calls these functions. 
#+BEGIN_EXAMPLE perl6
{ $_ * 2 }.WHAT
#+END_EXAMPLE
Will return =Block= which is what Perl6 calls these pieces of code
that can act on other things and return stuff, like this
#+BEGIN_EXAMPLE perl6
{ $_ * 2 }( 2 )
#+END_EXAMPLE
will apply the function to the number 2, returning, you guessed
it, 4. Functions are applied to things using these parentheses, and,
as you might have seen, =$_= is a stand-in for whatever the function is
called with, 2 in this case. 

We have already seen a bit of these chunks of code in action
previously, when using =grep=. 
#+BEGIN_EXAMPLE perl6
(1..1000).grep(* %% 11)
#+END_EXAMPLE
will return only numbers that are divisible by 11 by applying the
function =* %% 11=, which returns =True= for every element that is
divisible by 11 and forms a new list with all elements for which this
expression is true. Instead of =$_= as above we are using =*=, the
wildcard symbol, which, of course, is called =Whatever=
What we are using is, in fact, a /chunk of
code/ or =Block=, and in fact, we can rewrite the above expression this way:
#+BEGIN_EXAMPLE perl6
(1..1000).grep( {$_ %% 11} )
#+END_EXAMPLE
showing that what we are doing it handling =grep= a block that returns
a =True= or =False= value. There is still another way of doing it,
because in Perl6, just like in Perl, there are many ways of doing
everything: 
#+BEGIN_EXAMPLE perl6
(1..1000).grep: * %% 11
#+END_EXAMPLE
with the colon =:= opening the way for a block, a construction that is
totally equivalent to the one above and saves a character (a visible
character, anyway, because you will need the whitespace for
legibility). This means that =Whatever=, 
that is, =*= and the /topical/ variable, =$_=, can work in pretty much
the same way. However, they cannot be used interchangeably. The curly
block takes =$_=, while the colon or braced block takes =*=. This
#+BEGIN_EXAMPLE perl6
(1..1000).grep($_ %% 11)
#+END_EXAMPLE
will positively end in an error. Besides, =Whatever= positively means
whatever and you can use it for one or even several
parameters. However, =* * *= is not the thing with the biggest
readability ever.

/Pointy blocks/ to the
rescue. [[https://design.perl6.org/S06.html#___top][Pointy blocks]] have an arrow up front, and the arrow is
followed by a list of parameter names:
#+BEGIN_EXAMPLE perl6
(1..1000).grep: -> $a {$a %% 11}
#+END_EXAMPLE
This expression works exactly in the same as the rest of the
expressions above (remember, there are many ways of doing it), provided that whatever is behind
the arrow is also used as a variable inside the block in curly brackets. This is more verbose for
this kind of expression, but it is even more verbose to write it this
way, which is also equivalent:
#+BEGIN_EXAMPLE perl6
(1..1000).grep: sub ($a) {$a %% 11}
#+END_EXAMPLE

Meet the =sub= keyword, which is used to name /subroutines/. What are
subroutines? Actually, they are simply code blocks, and the fact that
this code behaves the same as above is exactly for that reason. We
have followed a path that takes us all the way from simple code 
chunks to /subroutines/ or, as they are generally called,
/functions/. Actually, our Blocks are basically subroutines with no
name, except that subroutines, them too, can have no name, as
above. However, they do have a /signature/, the list of parameters
behind the arrow or the word =sub=, in parentheses in this case.

Blocks can be simpler than subroutines, however, so we do not even
have to declare the names of those parameters. Use whatever you want,
like here, as long as they have the dollar and caret in front:
#+BEGIN_EXAMPLE perl6
{ $^foo ** $^bar }( 12,13 )
#+END_EXAMPLE
which will raise 12 to the 13th power; that is what =**= does. We are
using the oh so common foo and bar. In this case, the caret =^= is
produced by typing the key wherever the caret is and then the space, since it
is a key that is usually composed as a circumflex accent with other characters to produce
things like /brÃ»lÃ©/, which looks like it has been made up by some word
inventor, but is actually French. 

And while But do you remember that Perl 6
can easily deal with Unicode characters? From now on I propose to use
ÃŸ and Ã¾ as substitutes for the hackneyed =foo= and =bar=, like here
#+BEGIN_EXAMPLE perl6
{ ([*] 1..$^ÃŸ ) / ( [*] 1..$^Ã¾) * ([*] 1..($^ÃŸ - $^Ã¾)) }(5,3)
#+END_EXAMPLE
the part between braces computes $n \choose m$, that is, the
[[https://en.wikipedia.org/wiki/Binomial_coefficient][binomial coefficient]]. It does so by computing the factorial of ÃŸ,
which is what  =[*] 1..$^ÃŸ= does, remember, the meta-operator =[]=
applied to =*= applies the product to all the elements in the range
1:ÃŸ. And then it divides it by the factorial of Ã¾ multiplied by the
factorial of =ÃŸ - Ã¾=. Easy, right? Remember not to use too big
numbers, or it will take a little while. 

You actually have to use these placeholders if you want to build up
stuff using these chunks of code:
#+BEGIN_EXAMPLE perl6
( { $^ÃŸ * 2},{$^Ã¾ / 2} )
#+END_EXAMPLE
is an array of code blocks. The same thing with =$_= would yield a
rather weird error related to something being /raw/, but they are
placeholders all the same. And what do we have here? A little list of
code blocks. Before we have applied single code blocks to arrays of
non-code things. But code things are also things, or, as it is said it
functional programming, they are first-class citizens, so you can
apply code blocks to code blocks, like here:
#+BEGIN_EXAMPLE perl6
 ( { $^ÃŸ * 2},{$^Ã¾ / 2} ).grep:  { $_.(2) %% 2 }
#+END_EXAMPLE
Try to wrap your head around this, which is functional programming in
a nutshell. Remember how =$_= was used as a placeholder for things
like numbers before? We are using it here as a placeholder for code
blocks. So what $ $_.(2) $ does is to apply (herein the =.()) code
block to the number two, and then apply the /divisible by/ operator
=%%=. Eventually, it will be true if the code block, applied to the
number two, returns something that is divisible by two. In this case,
it will return an array with a single element, the first one in the
array, obviously. Once again, check this out, because it is quite
cool. Not cool as in can't-be-done-in-any-other-language, but still
cool: we have applied a function to a list of functions which returns
another list of functions. 

So these are functions for you. In Perl 6. 


** Going back to sequences

As we always do, we will try to apply what we know to defining and creating sequences, there are [[https://en.wikibooks.org/wiki/Real_Analysis/Sequences][lots of them]] than can be used for fun and profit. 

These expressions allow us to be much more flexible when building
sequences, which, as it happens, are becoming a showcase of Perl 6
power and features. For starters, these chunks of code can be used to
generate new sequences from old ones
#+BEGIN_EXAMPLE perl6
map *Â², 1..âˆž
#+END_EXAMPLE
This expression, that uses =map= for the first time, is the sequence
of all square natural numbers. =map= effectively /maps/, as in a
function, one value to another, creating a new element out of the old
elements of the array it maps via an expression. And the code chunk we
use for mapping is = *Â²=, which elevates to the second power
=Whatever=. If you want to see it in a more code-like form, 
#+BEGIN_EXAMPLE perl6
 (map {$^Ã¾Â²}, 1..âˆž)[333]
#+END_EXAMPLE
which uses the placeholder =$^Ã¾= instead of =Whatever= and, since it
is now a proper chunk of code, it has to be surrounded by curly
braces. Besides, we are using the result, which is an infinite
sequence, as a real object of which we extract element number 333. We
can use whatever element we want, since it is infinite, and this is,
besides, a way of holding in a lazy sequence all integer squares /in
the world/. Besides, this is a map as in a real function: defined from
an infinite set onto another infinite set. Mind you, it is not a
=Set=, just a set in the general sense. =Set=s are finite, sets are
not. 

You can also use these expressions to define series where new
elements are the result of applying some operation to the former
elements. See it here:
#+BEGIN_EXAMPLE perl6
(1,.9999999999999999, { $^ÃŸ * $^Ã¾}...âˆž)
#+END_EXAMPLE
This is a theoretically infinite series, which, in fact, goes to 0
pretty fast due to the actually finite nature of real numbers as
represented by computers, and where each term is the result of
multiplying the two previous terms. Just try and find out the 100
first terms and you will see that beyond the first 90 it is actually
not so far away from 0. You know, sequences can converge or, actually,
diverge.

Divergence is not actually a big deal. The whole idea of the
[[https://en.wikipedia.org/wiki/Mandelbrot_set][Mandelbrot set]] is built around it. Apply =zÂ²+c= to any number =c= and
see what happens. Does it diverge? It's not in the Mandelbrot
set. Does it not? Well, assign it a beautiful color and draw it. We do
it right here:
#+BEGIN_EXAMPLE perl6
(0,{$^ÃŸÂ²+0.5+0.3i}...âˆž)[^100]
#+END_EXAMPLE
Which is a sequence just like the old ones, only it's got an
=i=. Well, we were before talking about a number =c= and that is is
because it is a /complex/ number. Complex numbers are pairs of /real/
numbers, where one part of the couple is called real and the other,
the one that precedes =i=, /imaginary/. Just think about them like
your old =x= and =y= numbers, only iÂ² is equal to -1, so when we
elevate complex numbers to the second power, they can sometimes turn
into real numbers. No big deal, really; the big deal is that what we
have above is a series of complex numbers which will actually diverge
to a =Inf-Inf\i= value, which is how Perl represents a couple of
infinites. But not all values go to infinity.
#+BEGIN_EXAMPLE perl6
(0,{$^ÃŸÂ²-0.5+0.3i}...âˆž)[^100]
#+END_EXAMPLE
Precisely at the other side of the /real/ axis, this value will never
go to infinity; if you look at the mandelbrot set, it would be to the
left and top of the toppled heart-like shape, in the black area;
actually, it converges to something like
=-0.382545950491141+0.169962816621862i= after a few iterations. The
whole point of this is to show how, using just a simple expression,
you can defint complex mathematical relations and sequences. With Perl
6, of course. 

Besides, remember, functions are first class citizens, and sequences
two. You can create a code chunk that returns a sequence, and combine
placeholders to do so. Check this out:
#+BEGIN_EXAMPLE perl6
{ (0,{$^ÃŸÂ²+$_}...âˆž) }
#+END_EXAMPLE
This is a conde chunk that returns a sequence; the only thing we have
done is to put curly brackets around it. We have two different kind of
placeholders: =$_= will be a stand-in for whatever we handle to the
code chunk, while $^ÃŸ is the placeholder for the sequence itself. Perl
6 is able to find out which is which. And secuence generators generate
sequences:
#+BEGIN_EXAMPLE perl6
{ (0,{$^ÃŸÂ²+$_}...âˆž) }(.01+.1i)
#+END_EXAMPLE
Here we use parenthesis to hand the number that will substitute =$_=
in the sequence. And, of course, we can also use the infinite sequence
itself via a couple of more parentheses:
#+BEGIN_EXAMPLE perl6
({ (0,{$^ÃŸÂ²+$_}...âˆž) }(.01+.1i))[^100]
#+END_EXAMPLE
These last parentheses wrap around the sequence so that we can get the
range of its first 100 elements. Being as it is in the middle of the
belly of the set, it converges. 

* Î¶ - Understand errors
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
Shit eventually happens. But when it does, you must be ready to unshit
everything. The first thing that you have to understand is that errors
are your friends. 80 years of computer science have eventually yielded
systems and languages that, when something unexpected happens, explain
quite well what's the problem and even hint at what can be done to fix
it. Not go all the way to fix it, because that is actually why errors
happen, because the interpreter (in this case) or the system (in
general) cannot quite figure out what you mean and tell you in about
so many words. Maybe more.

Besides, error is too strong a word. You think of errors, and you
think of failure, as in /You are a/. That's not quite it. Errors are
actually misunderstandings, and always a path to eventually get things
right. They are a way of saying /You are probably right, but could you
please explain things in a slightly different way so that I can
actually confirm that?/

Let us see an example. Say that you skip a curly bracket, like this
#+BEGIN_EXAMPLE perl6
 ( { $^ÃŸ * 2},{$^Ã¾ / 2 )
#+END_EXAMPLE
Happens all the time, right? You skip a key, maybe avert your gaze to
check out incoming Telegram messages, whatever. And then that
happens. The interpreter will tell you this:
#+CAPTION: Errored expression in the REPL
#+NAME:   fig:simple error
[[./img/simple-error.png]]
First is says what's wrong. =Missing block=. It is not as helpful as,
"Hey, you forgot to put curly braces here", but, once again, if it
would have been able to figure that out it would have fixed it by
itself. But you can work with that error. If you cannot really point
out what's wrong, [[https://www.google.es/search?client=ubuntu&channel=fs&q=perl+6+missing+block&ie=utf-8&oe=utf-8&gfe_rd=cr&ei=aBWLWLDJCKOs8wfA_Y7IBA#safe=off&channel=fs&q=perl+6+%22missing+block%22][Google is your friend]], and will take you to 
[[http://blogs.perl.org/users/zoffix_znet/2016/08/the-awesome-errors-of-perl-6.html][this article of Zoffix Znet on, precisely, Perl 6 errors]]. That example
points out to the fact that Perl 6 says so when it is waiting for some
block to be there, or, as it happens here, to be properly
enclosed. Besides, the next line is even more helpful, pointing out
with a yellow â exactly the place where it should have been whatever
it was expecting, a curly bracket in this case. See? It has been just
a misunderstanding. Besides, it is much clearer later on. It is saying
it was expecting either an statement end, or modifier, or modifer
loop. The =}= is how you put an end to the block. The fact that there
are three different things is the reason why the error, let's not
call it error any more, the misunderstanding, is there in the first
place. There were three possible things that could go there, and poor
Perl 6 cannot understand which one you meant. It is no big deal,
really, but you see how reading the error carefully will help you find
the solution fast enough.

All misunderstandings in Perl 6 will follow the same structure. First, the error,
what is wrong. Second, where it is wrong, and third, what it was
expecting, and also the reason why it really could not recover from
the error. 

Some errors will not arrive from typing, but from applying what you
know of other languages here. 
#+BEGIN_EXAMPLE perl6
( 3 == 2)?"Yes":"No"
#+END_EXAMPLE
This ternary operator is not going to work here. However, there is a
very helpful error message
#+CAPTION: Errored expression in the REPL
#+NAME:   fig:perl5 error
[[./img/perl5-error.png]]
In this case, it is perfectly clear to Camelia, the friendly Perl6
interpreter, what's wrong. However, the problem is that in this new
Perl6 language it simply cannot be done that way, so it says =in Perl
6 please use ?? and !!=. You see? Not only I understand you, but take
you by the hand to the use of features thar are almost, but not quite,
the same as you did before.

Misunderstandings will happen here, there and everywhere. So it is
better not to make a big fuss about them. Check them out carefully,
try to follow the advice, if any, check out DuckDuckGo or Google for
possible solutions, and, if everything fails, you can still try and
get some help from the community. We will see to that later on. 

* Where did I put my keys?

Vectors and sequences are nice ways of arranging things, one after the
other, but they are just a simple way of getting to a particular
value in a bunch of things. One value is stored in the first position
(which, remember, is always 0), and another in the position 333. The
language takes care of doing some computation to access whatever is
stored in position 333. At the end of the day, you use a /key/, which
happens to be a number, to compute the place where the corresponding
value is stored, but sequences are simply lists of pairs with
position and the value stored in that position.

But think about hotel rooms. They do not go all the way from 0 to the
total number of rooms, they use some code that starts with the floor
number and that continues with some sequence of numbers in the floor.

* Working with, in and around data
Eventually you will need to give things a name, if only to avoid
cutting, pasting and recomputing stuff every time you need
it. /Variables/ store results and help you express, in a compact way,
complicated formulae. 

** Some things change. Some others don't.

Calling it something a variable might be a bit misleading when it
actually does not vary. However, in the very beginning everything
variable could vary, because they were simply a bunch of memory
positions that got to be called by a name. You wrote something else in
that position, well, it became actually /variable/. 

However, we are in the 21st century, and some variables actually
don't. Has anyone come up with another name? Noooo. So we get stuck
with it, and have to add some fancy-pants adjectives to tell apart the
variables that vary from the variables that do not. 

* ×’â€Ž - Markdown for documentation 
    :PROPERTIES:
    :UNNUMBERED: t
    :END:

Every project should have a =README.md= that explains what it is
about, for everyone else if it is public, for our future self if it is
not. That =README.md= you have already created is written using
Markdown, a simplified method that adds marks to plain text to denote
its role in the document: its importance, if they are headers, and
even if they represent a hyperlink or the inclusion of an image. 

* Stand in the shoulders: /modules/ and using whatever is available
If there is a single motto you should follow when programming, is this
one: /Don't reinvent the wheel/. Before sitting down to do something,
check out if it has been already done. In mature languages like Perl,
the answer is most probably Yes. In some others, like this Perl 6 we
are dealing with, your mileage may vary. 
* Î· - Web weaving
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
  
Whatever you do nowadays in computing, you will have to end up
presenting something somewhere, and that somewhere will most probably
be the web nowadays. So it does not harm, and it will benefit greatly,
to learn from now what the web is all about and how we can extract
information from it, use it to interact with people and publish our
data so that anyone in the whole wide world can see it. 
* Functions mean fun
Functions are just baptized pieces of code, but in the same way it
happens in magic kingdoms, knowing the name of something gives you
a handle to work with it. And work you will do. 
* ×“â€Ž - Getting help
   :PROPERTIES:
   :UNNUMBERED: t
    :END:
No matter how good you are, or how easy the learning curve is, you
might eventually get stuck, because you do not find your way in a maze
of documents, you do not really know what you are looking for so that
you cannot tell Google precisely what you want, or maybe you ended up
in an alley nobody has ever been before. You cry for help, and a
language is only as good as the facilities that there are for helping
people in your predicament. Fortunately, Perl 6 is very good at that. 
* Building up: /scripts/ and /programs/
Doodling with the REPL is fun, but eventually you will need to profit:
the program has to be stored and maybe shipped somewhere. Architecting
a script needs to put your computational thinking skills to work. 

** Show and tell

Any good program should be self describing, and of course a /good/
program is what /you/ do, except it is not. Do yourself a favor and
explain what is going on in your program all the time and any time you
do something that is too clever or exactly the opposite. That probably
means /always/. 
* Î¸ - Pack all your troubles in a container
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
  
Applications run nowadays in all kind of places, so eventually someone
found a way to put all the stuff you need to run them in a single
tupperware container and ship it anywhere you need them, in the same
way as you pack your potato omelette in a tupper and carry it to grab
a byte in a picnic or during your train trip to Poughkeepsie, as you
are wont to do. Same goes for programs. Create it, pack it, take it
anywhere: the cloud, your other computer, anywhere you please. And if
you add another tupper with mandarines and yet another with a few
cupcakes, you have got your whole snack-a-lot ready to take anywhere.

Applications nowadays are composed of the equivalent of a three or
even more course meal. They have several courses plus snacks and even
a doggie bag to pack leftovers and a plastic bag for organic
trash. You can carry them in several places on you and your clothes,
but it is much better to just pack containers for everything and lay
them out on the table when you are ready to eat. In the case of
applications, they can be data processing units, data storing units,
data fooing and data baring units. Does not really matter what they
are, but the thing it that /containerization/ makes easy the creation
of a whole suite that can be stored and shipped anywhere. 
* you decide
But sometimes it is better to let the machine do it for you.
* Ð³ - Always play it safe
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
 
As long as you have created a program that is out there on the
Internet, and you need to take care of sending it somewhere, in a
Docker container or some other way, you need to /play it safe/. A
cloud container or virtual machine instance is just a resource for
crackers and fraudsters which will use all means possible to get hold
of it and hold it hostage for ransom or use it for bitmining,
launching distributed denial of service attacks, or as a cache for
stolen data. Fortunately, cloud and hosting providers usually detect
and deactivate them as soon as they find out, but you might incur in
huge bills or maybe huge annoyances while you work out with customer
service to have that bill erased.

That is why, as soon as you start to write your programs, you need to
play it safe. 
* Interacting with the user
Programs are created to be used. Many of them will be used by just
you. But some of them will be out there. You have to build them for an
ideal user, and that ideal user is a 90-year old FSB agent that is on
one hand not familiar with modern technology and that on the other
hand is familiar enough to try and break and enter in your program to
steal your family secrets. User interfaces have to be easy on the
user, but also secure. Never forget that. 
* Î¹ - Testing for the win
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
  
/If it is not tested, it is broken/ is something that you should learn
as soon as you start to crank out code. It actually means /If it is
not *automatically* tested, it is broken/, that is, it is not enough
that you give it two or maybe one input, and declare yourself
satisfied with it. No, son, that is not testing and you know it. 
* Interacting with the system
Systems are full of interesting things, and nowadays there is also the Internet, which is full of stuff too. Getting data back and forth is something you are going to need to do, like, all the time. 
* Îº - lay the internet to rest
* It's deja vu all over again
What computers are good at is at repeating things. However, that has
not made anyone name them repeaters instead of computers. Actually, in
some European countries they are called /sorters/, from the French
/ordinateur/ that means exactly that. Looks like French people are
good at making up words and also naming things in unexpected ways. 
* Ð” - Find the bug
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
  
Testing reduces the need to find errors, but eventually some non-tested feature or a combination of things will make your program behave unexpectedly. No worries. /Debugging/ is the way to go. 

* Regular expressions
Machine learning is all about understanding text. That text does not
come in a shape you can easily process it. Regular expressions help
you deal with text that is not totally structured, but that has some
regularities in it. 
* Î» - What you need to know about the cloud
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

The /cloud/ is where you run your programs nowadays. That is all you
need to know.

Not really. But almost.

* Keep things where you can get them back again
And this is like the lengthiest chapter title ever, but it is really
important to learn to store data and do so in a way that can be easily
retrieved later on . 
* Ð¶- Deploying to the cloud
You have probably been told, by myself in the previous chapter, that
the cloud is where you run your program. But it is not going to go,
all by itself, to a cumulonimbus out there. You have to physically
take it, and that is what is called /deploying/. 

* Using stuff from the cloud
The isolated application is something that existed in the early
nineties, but not any more. All applications are connected, in some
way or another, to other applications, sometimes over the Internet,
and sometimes to other computers you do not own. Application
programming interfaces, or APIs, allow you to do so, which is
great. Those programming interfaces can be easily used to perform many
of the tasks that programs perform routinely, like authenticating or
logging activities. We will see a few of these. 
* Î¼ - The world is my platform
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
When creating a program, you can literally get the world to process part of your stuff, or obtain data from the same world. /Application programming interfaces/ make accessible, over the Internet, functions that would be annoying or simply impossible to have on your own computer. 
* Analyzing data
* Î½ - Performance to the max
The first objective you have when writing a program is to make it
work. The second is to make it work /all the time/. The third is to
make it work /faster, and all the time/. Performance matters.
* a classy affair
We have already seen that data usually does not walk alone. It has
some properties, and there are some things you can do to certain kind
of data, some functions you can call, which you cannot in other types
of data. At the end of the cay, a class is only another way of calling
a Type. Which means you can create your own types, and then create
objects that have that type. 

* Î¾ - Agile development for the win
* Keeping track of time
You will have to deal with them all the time, so they might as well be part of the system. 
