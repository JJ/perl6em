<a id="org6fe64c6"></a>

# Building up: *scripts* and *programs*

Doodling with the REPL is fun, but eventually you will need to profit:
the program has to be stored and maybe shipped somewhere. Architecting
a script needs to put your computational thinking skills to work. 


<a id="org7584d3c"></a>

## Show and tell

Any good program should be self describing, and of course a *good*
program is what *you* do, except it is not. Do yourself a favor and
explain what is going on in your program all the time and any time you
do something that is too clever or exactly the opposite. That probably
means *always*. 


<a id="org30f4af8"></a>

# θ - Pack all your troubles in a container

Applications run nowadays in all kind of places, so eventually someone
found a way to put all the stuff you need to run them in a single
tupperware container and ship it anywhere you need them, in the same
way as you pack your potato omelette in a tupper and carry it to grab
a byte in a picnic or during your train trip to Poughkeepsie, as you
are wont to do. Same goes for programs. Create it, pack it, take it
anywhere: the cloud, your other computer, anywhere you please. And if
you add another tupper with mandarines and yet another with a few
cupcakes, you have got your whole snack-a-lot ready to take anywhere.

Applications nowadays are composed of the equivalent of a three or
even more course meal. They have several courses plus snacks and even
a doggie bag to pack leftovers and a plastic bag for organic
trash. You can carry them in several places on you and your clothes,
but it is much better to just pack containers for everything and lay
them out on the table when you are ready to eat. In the case of
applications, they can be data processing units, data storing units,
data fooing and data baring units. Does not really matter what they
are, but the thing it that *containerization* makes easy the creation
of a whole suite that can be stored and shipped anywhere. 

<a id="org2a0c0d4"></a>
# г - Always play it safe

As long as you have created a program that is out there on the
Internet, and you need to take care of sending it somewhere, in a
Docker container or some other way, you need to *play it safe*. A
cloud container or virtual machine instance is just a resource for
crackers and fraudsters which will use all means possible to get hold
of it and hold it hostage for ransom or use it for bitmining,
launching distributed denial of service attacks, or as a cache for
stolen data. Fortunately, cloud and hosting providers usually detect
and deactivate them as soon as they find out, but you might incur in
huge bills or maybe huge annoyances while you work out with customer
service to have that bill erased.

That is why, as soon as you start to write your programs, you need to
play it safe. 


<a id="orgb5f34e7"></a>

# Interacting with the user

Programs are created to be used. Many of them will be used by just
you. But some of them will be out there. You have to build them for an
ideal user, and that ideal user is a 90-year old FSB agent that is on
one hand not familiar with modern technology and that on the other
hand is familiar enough to try and break and enter in your program to
steal your family secrets. User interfaces have to be easy on the
user, but also secure. Never forget that. 


<a id="org5bb63a6"></a>

# ι - Testing for the win

*If it is not tested, it is broken* is something that you should learn
as soon as you start to crank out code. It actually means *If it is
not **automatically** tested, it is broken*, that is, it is not enough
that you give it two or maybe one input, and declare yourself
satisfied with it. No, son, that is not testing and you know it. 


<a id="org6f29b42"></a>

# Interacting with the system

Computer systems are full of interesting things, and nowadays there
is also the Internet, which is full of stuff too. Getting data back
and forth is something you are going to need to do, like, all the
time. This includes working with files, but not only that, dealing
with data and interfaces that are somewhere across the world. 


<a id="orgff0c311"></a>

# κ - lay the Internet to rest


<a id="org652a59d"></a>

# It's deja vu all over again

What computers are good at is at repeating things. However, that has
not made anyone name them repeaters instead of computers. Actually, in
some European countries they are called *sorters*, from the French
*ordinateur* that means exactly that. Looks like French people are
good at making up words and also naming things in unexpected, but accurate, ways. 


<a id="org9d98b4e"></a>

# Д - Find the bug

Testing reduces the need to find errors, but eventually some non-tested feature or a combination of things will make your program behave unexpectedly. No worries. *Debugging* is the way to go. 


<a id="org1632174"></a>

# Understanding text

Machine learning is all about understanding text. That text does not
come in a shape you can easily process it. Regular expressions help
you deal with text that is not totally structured, but that has some
regularities in it. And from regular expressions you can build up grammars, powerful tools that can extract information from any kind of text structured just so.




<a id="org2f8d612"></a>

# λ - What you need to know about the cloud

The *cloud* is where you run your programs nowadays. That is all you
need to know.

Not really. But almost.


<a id="orgc786bee"></a>

# Keep things where you can get them back again

And this is like the lengthiest chapter title ever, but it is really
important to learn to store data and do so in a way that can be easily
retrieved later on. 


<a id="org5792ebc"></a>

# ж- Deploying to the cloud

You have probably been told, by myself in the previous chapter, that
the cloud is where you run your program. But it is not going to go,
all by itself, to a cumulonimbus out there. You have to physically
take it, and that is what is called *deploying*. 


<a id="org13d0032"></a>

# Using stuff from the cloud

The isolated application is something that existed in the early
nineties, but not any more. All applications are connected, in some
way or another, to other applications, sometimes over the Internet,
and sometimes to other computers you do not own. Application
programming interfaces, or APIs, allow you to do so, which is
great. Those programming interfaces can be easily used to perform many
of the tasks that programs perform routinely, like authenticating or
logging activities. We will see a few of these. 


<a id="orga3f6367"></a>

# μ - The world is my platform

When creating a program, you can literally get the world to process part of your stuff, or obtain data from the same world. *Application programming interfaces* make accessible, over the Internet, functions that would be annoying or simply impossible to have on your own computer. 


<a id="org184681a"></a>

# Analyzing data


<a id="orgf87e63b"></a>

# ν - Performance to the max

The first objective you have when writing a program is to make it
work. The second is to make it work *all the time*. The third is to
make it work *faster, and all the time*. Performance matters.


<a id="orgd479c5e"></a>

# A classy affair

We have already seen that data usually does not walk alone. It has
some properties, and there are some things you can do to certain kind
of data, some functions you can call, which you cannot in other types
of data. At the end of the cay, a class is only another way of calling
a Type. Which means you can create your own types, and then create
objects that have that type. 


<a id="orgbdaaee6"></a>

# ξ - Agile development for the win


<a id="orgf92df78"></a>

# Keeping track of time

You will have to deal with them all the time, so they might as well be part of the system. 

